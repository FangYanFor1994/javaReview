### 一、构建springboot项目入门

#### 1.使用spring初始化器创建springboot项目

#####1.1步骤

![1571590153462](assets/1571590153462.png)

![1571590186989](assets/1571590186989.png)

![1571590211484](assets/1571590211484.png)

![1571590236127](assets/1571590236127.png)

![1571590271853](assets/1571590271853.png)

##### 1.2访问

```java
编写controller即可访问：（由于引入了web模块，支持springMVC）
默认端口号：8080   

@Controller
public class HelloController {
    @ResponseBody
    @RequestMapping("/hello")
    public String hello(){
        return "Hello World....";
    }
}
```

### 二、springboot核心配置

#### 1.springboot的配置文件类型(properties和yml)

```java
1.application.properties / application.yml
2.配置文件的作用：修改springboot的默认配置；
				springboot有很多默认配置，详见官网：
```

https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#common-application-properties

#### 2.yml语法格式

```yaml
1.key: value 表示一对键值对（冒号后面必须有空格）
2.使用空格缩进表示层级关系，左侧缩进空格数不重要，只要同一层级元素左侧对其即可；
3.字符串默认不加引号
4.对象&Map
	一般写法：
		emp:
		  lastName: xiaomeng
		  age: 22
		  salary: 10000
	行内写法：
		emp: {lastName: xiaomeng, age: 22, salary: 10000}
		
5.数组（List & set）
	一般写法：
		fortes:
		  - java
		  - python
		  - hadoop
	行内写法：
		fortes: [java, python, hadoop]
```

**注意：properties中map和list的写法**

```properties
#对象&map
	emp.map.key1=value1
	emp.map.key2=value2
#list
	emp.list=one,two,three
```

#### 2.@ConfigurationProperties和@Value配置文件注入值的比较

**2.1@ConfigurationProperties配置文件注入值**

```java
@Component
@ConfigurationProperties(prefix = "emp")
public class Emp {
  private String lastName;
  private Integer age;
  private Double salary;
  private Boolean boss;
  private Date birthday;
  private Map map;
  private List list;
    ..getter&setter..
}
```

**2.2@Value配置文件注入值**

```java
  @Value("${emp.last-name}")
  private String lastName;
  @Value("#{10*2}")
  private Integer age;
  @Value("8000")
  private Double salary;
```

**2.3总结@Value 与 @ConfigurationProperties获取值差异**

![1571592548574](assets/1571592548574.png)

注：如果只是某个业务逻辑中需要获取配置文件某个属性值则使用@Value，如果专门使用Javabean和配置文件映射，则使用@ConfigurationProperties

#### 3.@PropertySource用于加载局部配置文件

```java
//PropertySource读取value指定的配置文件而非默认的配置文件
@PropertySource(value = {"classpath:emp.properties"})
@Component
@ConfigurationProperties(prefix = "emp")
@Validated
public class Emp {
  private String lastName;
  private Integer age;
  private Double salary;
  private Boolean boss;
  private Date birthday;
  private Map map;
  private List list;
  //特长
  private Forte forte;
```

#### 4.@ImportResource使用xml配置

```java
//将@ImportResource(locations = {"classpath:spring01.xml"})注解到配置类上，就会读取spring01.xml里面的配置
@ImportResource(locations = {"classpath:spring01.xml"})
@SpringBootApplication
public class SpringBoot02ConfigApplication {
  public static void main(String[] args) {
    SpringApplication.run(SpringBoot02ConfigApplication.class, args);
 }
}
```

#### 5.自定义配置类向容器注入组件

```java
/**
* @Configuration 用于标识当前类是一个配置类, 来表示对应的Spring配置文件
*/
@Configuration
public class EmpConfig {
  /**
  * @Bean 标识的方法用于向容器注入组件
  * 1. 方法的返回值就是注入容器中的组件对象,
  * 2. 方法名是这个组件对象的 id 值
  */
  @Bean
  public EmpService empService2() {
    System.out.println(" @Bean 注解已经将 EmpService 组件注入");
    return new EmpService();
 }
}

//总结：配置类的作用类似于application.xml，@Bean相当于<bean></bean>标示一个类注入到spring容器中，   方法名是<bean id="empService2">中id
```

#### 6.Profile多环境支持

**properties文件激活**

```
创建两个文件  application-dev.properties 与  application-prod.properties；
在主配置文件  application.properties 中指定  spring.profiles.active=dev，即可激活application-dev.properties文件；
```

**yml文件激活**

```yaml
#yaml支持多文档块方式 ---
server:
	port: 8081   # 默认端口号
spring:
    profiles:
        active: prod #激活哪个profile , 当前激活的是 dev 开发环境
---
server:
	port: 8082
spring:
	profiles: dev #指定属于哪个环境, dev 环境时使用
---
server:
	port: 8888
spring:
	profiles: prod #指定属于哪个环境, prod 环境时使用
```

#### 7.配置文件加载位置

```java
1.springboot启动时，会扫描以下位置的application.properties或application.yml作为默认配置文件：
2.高优先级的配置内容会覆盖低优先级的配置内容
```

![1571594139298](assets/1571594139298.png)

### 三、springboot日志配置

#### 1.slf4j+logback的组合形式

```
Spring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置；
spring官网参考文档：
https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#boot-features-logging
```

```properties
1.日志级别（低->高）：
	trace < debug < info < warn <error
2.springboot默认设置级别为info(也称root级别)
3.调整日志级别：
	3.1修改指定包下的日志级别：
		logging.level.com.fy=trace
	3.2设置root级别：
		logging.level.root=debug
```

#### 2.修改日志文件生成路径

**修改生成日志文件两种方式如下**

![1571672547699](assets/1571672547699.png)

**示例：**

```properties
#输出到当前项目根路径下的springboot.log文件中
logging.file=springboot.log
#注：logging.file=D:/springboot.log 也可以将生成日志放入指定磁盘目录

#输出到当前项目所在的磁盘根路径下的/springboot/log目录中的spring.log文件中
logging.path=springboor/log

推荐使用logging.file可以指定路径和文件名，而logging.path不能指定文件名
```

#### 3.修改日志输出格式

```properties
#日志输出格式说明：
	# %d 输出日期时间，
	# %thread 输出当前线程名，
	# %-5level 输出日志级别，左对齐5个字符宽度，
	# %logger{50} 输出全类名最长50个字符，超过按照句点分割，
	# %msg 日志信息
	# %n 换行符
	
#修改控制台输出的日志格式
logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n

#修改文件中输出的日志格式
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} >>> [%thread] >>> %-5level >>>
%logger{50} >>> %msg%n
```

#### 4.自定义日志配置

1）在 spring-boot-2.0.6.RELEASE.jar! \org\springframework\boot\logging\logback\base.xml 做了日志的
默认配置

```xml
<included>
 <!--日志格式默认规定-->
 <include resource="org/springframework/boot/logging/logback/defaults.xml" />
 <!--日志文件默认生成路径-->
 <property name="LOG_FILE"
value="${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}"/>
 <!--控制台日志信息默认配置-->
  <include resource="org/springframework/boot/logging/logback/console-appender.xml"
/>
 <!--文件中日志信息默认配置-->
 <include resource="org/springframework/boot/logging/logback/file-appender.xml" />
  <!--日志级别默认为： info -->
  <root level="INFO">
   <appender-ref ref="CONSOLE" />
   <appender-ref ref="FILE" />
 </root>
</included>
```

2)如果springboot的日志功能无法满足我们的需求（比如异步日志记录等），我们可以自己定义日志配置文件

```
在类路径下存放对应的日志框架配置文件即可，springboot 就不会使用它默认的日志配置了；
```

**在resource目录下创建logback.xml文件如下：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--梦学谷 www.mengxuegu.com

scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。
debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。
-->
<configuration scan="false" scanPeriod="60 seconds" debug="false">
    <!-- 定义日志的根目录 -->
    <property name="LOG_HOME" value="/logs/log" />
    <!-- 定义日志文件名称 -->
    <property name="appName" value="mengxuegu-spring-boot"></property>
    <!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 -->
    <appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        <!--
			日志输出格式说明：
				    %d 		输出日期时间
				    %thread 输出当前线程名
				    %-5level  	输出日志级别，左对齐5个字符宽度
				    %logger{50} 输出全类名最长50个字符，超过按照句点分割
				    %msg  	日志信息
				    %n    	换行符
        -->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} - [%thread] - %-5level - %logger{50} - %msg%n</pattern>
        </layout>
    </appender>

    <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 -->  
    <appender name="appLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 指定日志文件的名称 -->
        <file>${LOG_HOME}/${appName}.log</file>
        <!--
        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名
        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。
        -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--
				滚动时产生的文件的存放位置及文件名称 %d{yyyy-MM-dd}：按天进行日志滚动 
				%i：当文件大小超过maxFileSize时，按照i进行文件滚动
            -->
            <fileNamePattern>${LOG_HOME}/${appName}-%d{yyyy-MM-dd}-%i.log</fileNamePattern>
            <!-- 
            可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。
			假设设置每天滚动，且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。
			注意，删除旧文件是，那些为了归档而创建的目录也会被删除。
            -->
            <MaxHistory>365</MaxHistory>
            <!-- 
            当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy
            -->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <!-- 日志输出格式： -->     
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [ %thread ] - [ %-5level ] [ %logger{50} : %line ] - %msg%n</pattern>
        </layout>
    </appender>

    <!-- 
		logger主要用于存放日志对象，也可以定义日志类型、级别
		name：表示匹配的logger类型前缀，也就是包的前半部分
		level：要记录的日志级别，包括 TRACE < DEBUG < INFO < WARN < ERROR
		additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，
		false：表示只用当前logger的appender-ref，true：
		表示当前logger的appender-ref和rootLogger的appender-ref都有效
    -->
    <!-- hibernate logger -->
    <logger name="com.mengxuegu" level="debug" />
    <!-- Spring framework logger -->
    <logger name="org.springframework" level="debug" additivity="false"></logger>


    <!-- 
    root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，
    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 
    -->
    <root level="info">
        <appender-ref ref="stdout" />
        <appender-ref ref="appLogAppender" />
    </root>
</configuration> 
```

### 四、springboot的web开发

web开发官方文档：

https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#boot-features-spring-mvc

#### 1.web开发支持

```java
1.springboot的web启动器spring-boot-starter-web依赖了spring-boot-starter-tomcat，spring-web，spring-webmvc从而达到内嵌的servlet和springmvc的支持，直接便可以进行web开发；
```

#### 2.静态资源的映射规则

**对静态资源的映射规则可以通过分析WebMvcAutoConfiguration自动配置类得到**

##### 2.1webjars静态资源映射

在 WebMvcAuotConfiguration.addResourceHandlers() 分析webjars 资源映射

![1571846301317](assets/1571846301317.png)

```xml
1.所有/webjars/**请求都去classpath:/META-INF/resources/webjars/目录下寻找对应资源；
2.webjars:以jar包的方式引入静态资源；
	webjars官网： https://www.webjars.org/
3.在官网打开资源文件的依赖配置信息，然后粘贴到pom.xml中
	<!--引入 jquery webjars-->
    <dependency>
      <groupId>org.webjars</groupId>
      <artifactId>jquery</artifactId>
      <version>3.3.1</version>
    </dependency>
4.访问localhost:8080/webjars/jquery/3.3.1/jquery.js会在下面路径中查找：
```

![1571846597532](assets/1571846597532.png)

##### 2.2其他静态资源映射

当接受到/**请求访问资源时，会被映射到下面4个类路径下的静态资源目录中查找

```properties
classpath:/META-INF/resources/
classpath:/resources/
classpath:/static/
classpath:/public/


#说明:这些在springboot的webMvcAutoConfiguration自动配置类中定义好了静态资源访问规则,而在springMVC框架中需要手动在springmvc.xml文件中配置静态资源访问路径,目的是让前端控制器可以直接访问
#示例:<mvc:resources location="/static/" mapping="/static/**"></mvc:resources>
```

访问 localhost:8080/style.css 会在上面四个静态资源路径 中查找文件

##### 2.3欢迎页映射

访问localhost:8080/ 会在下面5个路径中查找index.html页面；

```properties
classpath:/META-INF/resources/
classpath:/resources/
classpath:/static/
classpath:/public/
/: 当前项目根路径下
```

##### 2.4图标映射

```properties
springboot会在静态资源目录下与根路径下查找favicon.ico文件，如果存在，springboot会自动将其设置为应用图标；

classpath:/META-INF/resources/
classpath:/resources/
classpath:/static/
classpath:/public/
/: 当前项目根路径下
```

#### 3.Thymeleaf模板引擎

##### 3.1Thymeleaf引入和使用

1.引入Thymeleaf

```xml
<!-- thymeleaf 模板启动器 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

2.使用Thymeleaf

**模板放在哪里**

```java
@ConfigurationProperties(   prefix = "spring.thymeleaf" )
public class ThymeleafProperties {
  private static final Charset DEFAULT_ENCODING;
  public static final String DEFAULT_PREFIX = "classpath:/templates/";
  public static final String DEFAULT_SUFFIX = ".html";
    
    
//通过上面源码发现，将HTML页面放在classpath:/templates/目录下，thymeleaf能自动渲染
```

**导入Thymeleaf的名称空间**

```html
<!--导入名称空间后可以使用th: 的语法-->
<html xmlns:th="http://www.thymeleaf.org">
```

##### 3.2Thymeleaf语法

**1）常用属性**

| 优先级 | 属性名                                     | 作用                                                         |
| :----: | ------------------------------------------ | ------------------------------------------------------------ |
|   1    | th:insert <br>th:replace                   | 引入片段，与th:fragment声明组合使用；类似于jsp:include       |
|   2    | th:each                                    | 遍历，类似于c:forEach                                        |
|   3    | th:if<br>th:unless<br>th:swith<br>th:case  | 条件判断，类似于c:if                                         |
|   4    | th:object<br>th:with                       | 声明变量                                                     |
|   5    | th:attr<br>th:attrprepend<br>th:attrappend | 修改任意属性，prepend前面追加,append后面追加                 |
|   6    | th:value<br>th:href<br>th:src              | **修改任意HTML原生属性值**                                   |
|   7    | th:text<br>th:utext                        | 修改标签体中的内容；<br>th:text转义特殊字符，即h1标签以文本显示出来<br>th:utext是不转义特殊字符，即h1标签展现出来的本来的效果 |
|   8    | th:fragment                                | 声明片段                                                     |
|   9    | th:remove                                  | 移除片段                                                     |

**2）标准表达式语法**

参考 Thymeleaf 官方文档  4 Standard Expression Syntax

```properties
一、Simple expressions（表达式语法）
 1. Variable Expressions(变量表达式): ${...} （参考： 4.2 Variables）
 1)、获取变量值；使用OGNL表达式；
 2）、获取对象的属性, 调用方法
 3）、使用内置的基本对象：
     #ctx : the context object.(当前上下文对象)
     #vars: the context variables.(当前上下文里的变量)
     #locale : the context locale. (当前上下文里的区域信息)
     下面是Web环境下的隐式对象
     #request : (only in Web Contexts) the HttpServletRequest object.
     #response : (only in Web Contexts) the HttpServletResponse object.
     #session : (only in Web Contexts) the HttpSession object.
     #servletContext : (only in Web Contexts) the ServletContext object.
     示例: ${session.foo} (用法参考: 18 Appendix A: Expression Basic Objects)
     
    4）、使用内置的工具对象：(用法参考: 19 Appendix B: Expression Utility Objects)
     #execInfo : information about the template being processed.
     #messages : methods for obtaining externalized messages inside variables
expressions, in the same way as they would be obtained using #{…} syntax.
     #uris : methods for escaping parts of URLs/URIs
     #conversions : methods for executing the configured conversion service (if
any).
     #dates : methods for java.util.Date objects: formatting, component
extraction, etc.
     #calendars : analogous to #dates , but for java.util.Calendar objects.
     #numbers : methods for formatting numeric objects.
     #strings : methods for String objects: contains, startsWith,
prepending/appending, etc.
     #objects : methods for objects in general.
     #bools : methods for boolean evaluation.
     #arrays : methods for arrays.
     #lists : methods for lists.
     #sets : methods for sets.
     #maps : methods for maps.
     #aggregates : methods for creating aggregates on arrays or collections.
     #ids : methods for dealing with id attributes that might be repeated (for
example, as a result of an iteration).  
     
 2. Selection Variable Expressions(选择表达式): *{...}
 （参考：4.3 Expressions on selections）
 1）、和${}在功能上是一样， 额外新增：配合 th:object 使用
     <div th:object="${session.user}">
     省得每次写${session.user.firstName}, 直接取出对象，然后写对象名即可
       <p>Name: <span th:text="*{firstName}">Sebastian</span> </p>
       <p>Email: <span th:text="*{email}">Saturn</span> </p>
     </div>
 3. Message Expressions（获取国际化内容）: #{...}  （参考：4.1 Messages）
 	4. Link URL Expressions（定义URL）: @{...} （参考：4.4 Link URLs）
 5. Fragment Expressions（片段引用表达式）: ~{...} （参考：4.5 Fragments）
 <div th:insert="~{commons :: main}">...</div>
二、Literals（字面量） （参考： 4.6 Literals）
 1. Text literals: 'one text' , 'Another one!' ,…
 2. Number literals: 0 , 34 , 3.0 , 12.3 ,…
 3. Boolean literals: true , false
 4. Null literal: null
 5. Literal tokens: one , sometext , main ,…
三、Text operations（文本操作） （参考： 4.7 Appending texts）
 1. String concatenation: +
 2. Literal substitutions: |The name is ${name}|
 
四、Arithmetic operations（数学运算） （参考： 4.9 Arithmetic operations）
 1. Binary operators: + , - , * , / , %
 2. Minus sign (unary operator): -
五、Boolean operations（布尔运算）
 1. Binary operators: and , or
 2. Boolean negation (unary operator): ! , not
 
五、Comparisons and equality（比较运算）  （参考： 4.10 Comparators and Equality）
 1. Comparators: > , < , >= , <= ( gt , lt , ge , le )
 2. Equality operators:  == , != ( eq , ne )
 
六、Conditional operators(条件表达式;三元运算符) （参考： 4.11 Conditional expressions）
 1. If-then: (if) ? (then)
 2. If-then-else: (if) ? (then) : (else)
 3. Default: (value) ?: (defaultvalue)
七、Special tokens（特殊操作） (参考： 4.13 The No-Operation token)
 1. No-Operation: _
```

##### 3.3实例代码演示

###### 3.3.1声明与引入公共片段

```html
<!--header.html-->
<body>
  <!--声明公共片段-->
  <!-- 方式1：-->
  <div th:fragment="header_common">
   这是th:fragment声明公共片段
  </div>
  <!-- 方式2：选择器写法-->
  <div id="header_common_id">
   这是id选择器声明公共片段
  </div>
</body>

<!--success.html-->
<!-- success.html 引入头部公共片段   -->
<!--方式1：
  header : 公共片段所在模板的文件名
  header_common ：声明代码片段名 -->
<div th:replace="header :: header_common"></div>
<!--方式2：选择器写法
  header : 公共片段所在模板的文件名
  #header_common_id: 声明代码片的id值
-->
<div th:replace="header :: #header_common_id"></div>


<!--
  th:insert 和 th:replace的区别
    th:insert和th:replace都可以引入片段，两者的区别在于
    th:insert： 保留引入时使用的标签
    th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签
-->
<h2 th:insert="header :: #header_common_id"></h2>
```

###### 3.3.2迭代th:each 

```html
<!--1.常用迭代方式-->
    <tr th:each="user : ${userList}">
        <!--每次迭代都会生成一个当前标签-->
    	<td th:text="${user.name}"></td>
    </tr>

    <ul>
      <!--方式2：-->
      <!--作用在同一个标签上， 每次迭代生成一个当前标签-->
      <li th:each="user : ${userList}" th:text="${user.name}"></li>
    </ul>

<!--获取迭代状态 th:each="user, iterStat : ${userList}"-->
<!--
    user :   第1个值,代表每次迭代出对象,名字任意取
    iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性:
    index : 当前迭代下标 0 开始
    count : 当前迭代下标 1 开始
    size : 获取总记录数
    current : 当前迭代出的对象
    even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值)
    first : 当前是否为第一个元素
    last : 当前是否为最后一个元素
  -->
  <tr th:each="user, iterStat : ${userList}">
    <td th:text="${iterStat.count}">0</td>
    <td th:text="${user.username}">mengxuegu</td>
    <td th:text="${user.gender == 1 ? '女' : '男'}">未知</td>
    <td th:text="${iterStat.size}">0</td>
    <td th:text="${iterStat.even}? '偶数' : '奇数'"></td>
    <td th:text="${iterStat.first}"></td>
    <td th:text="${iterStat.last}"></td>
  </tr>
```

###### 3.3.3条件判断

**th:if**

```html
<h3 th:if="not ${#lists.isEmpty(userList)}">th:if判断,如果此文字显示说明有值</h3>
<h3 th:unless="${#lists.isEmpty(userList)}">th:unless判断,如果此文字显示说明有值</h3>

<!--
说明：1.th：if 不仅判断返回值为true的表达式，还判断一些特殊的表达式。
		如果值为null，则返回false；
		如果值不为null，以下情况均返回true：
			1）如果值是boolean类型并且返回true；
			2）如果值是数值类型并且不为0；
			3）如果值是字符串类型并且不为可空；
			4）如果值是字符串并且内容不是"false","off","no";
			5)如果值不是上述类型也返回true；
	2.th:unless与th:if作用正好相反。
-->
```

**th:swith  th:case**

```html
<div th:switch="${sex}">
  <!--1女, 2男-->
  <p th:case="1">女</p>
  <!--判断sex的值和下面取出man的值是否相等,相等则显示-->
  <p th:case="${man}">男</p>
  <!--如果值都不在上述case里，则th:case="*"语句生效。-->
  <p th:case="*">未知</p>
</div>
```

###### 3.3.4th:object直接取出对象

**使用th:object直接取出对象，然后写对象里的属性名即可获取属性值**

```html
<!--使用th:object 直接取出对象，然后写对象里的属性名即可获取属性值-->
<div th:object="${session.user}">
  <p>
   姓名:<span th:text="*{username}">xxxx</span>
  </p>
  <p>
   性别:<span th:text="*{gender == 1 ? '女' : '男'}">xxxx</span>
  </p>
</div>
```

##### 3.4springboot热部署

步骤：

1. 在springboot开发环境下禁用模板缓存

   ```properties
   #开发环境下关闭thymeleaf模板缓存，thymeleaf默认是开启状态
   spring.thymeleaf.cache=false
   ```

2. 添加springboot Devtools热部署依赖

```xml
<!--热部署-->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-devtools</artifactId>
</dependency>
```

3. idea和eclipse不同，idea需要做小调整

```
1.在eclipse中，修改完文件后要手动保存，他就会自动编译，就会触发热部署现象；
2.在idea中，修改完文件后自动保存，默认不会自动编译文件，需要手动编译'ctrl+F9'
```

#### 4.分析springmvc自动配置WebMvcAutoConfiguration

springboot为springmvc提供了适用于多数应用的自动配置功能（WebMvcAutoConfiguration）.

在spring默认配置基础上，自动配置添加了以下特性：

1. *引入ContentNegotiatingViewResolver和BeanNameViewResolver beans*

- 自动配置了视图解析器ViewResolver(根据方法返回值获取视图对象view,视图对象决定如何渲染?重定向or转发)   (springMVC框架中配置视图解析器配置在springmvc.xml中)

* ContentNegotiatingViewResolver:组合所有的视图解析器(通过源码分析出)

  ```java
  public class ContentNegotiatingViewResolver
   //146    
   public View resolveViewName(String viewName, Locale locale) throws Exception {
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes
          , "No current ServletRequestAttributes");
    List<MediaType> requestedMediaTypes =
      this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) {
      //选择所有候选的视图对象
      List<View> candidateViews = this.getCandidateViews(viewName, locale,
                               requestedMediaTypes);
      //从候选中选择最合适的视图对象
      View bestView = this.getBestView(candidateViews, requestedMediaTypes,
                      attrs);
     
   //存入所有视图解析器
   private List<ViewResolver> viewResolvers;
   107
   protected void initServletContext(ServletContext servletContext) {
      Collection<ViewResolver> matchingBeans =
        BeanFactoryUtils.beansOfTypeIncludingAncestors(
        //从容器中获取所有的视图解析器
        this.obtainApplicationContext(), ViewResolver.class).values();
  ```

  * 自定义视图解析器:可以@Bean向容器中添加一个我们自定义的视图解析器,即可被容器管理使用

    ```java
    @Bean
    public ViewResolver myViewResolver () {
    return new MyViewResolver();
    }
    private  class MyViewResolver implements ViewResolver {
      @Override
      public View resolveViewName(String s, Locale locale) throws Exception {
      return null;
     }
    }
    ```

2. 自动注册[^Converter],[^GenericConvert],and [^Formatter]beans.

   * converter 转换器;如:如文本类型转换为目标类型,true转Boolean类型;

   * GenericConvert: 转换器,spring内部在注册时,会将Converter先转为GenericConverter之后,再统一对GenericConverter注册.
   * Formatter: 格式化器;如:2017/12/17格式化Date类型;

```java
@Bean
public FormattingConversionService mvcConversionService() {
  //传入日期格式， spring.mvc.date-format配置日期格式
  WebConversionService conversionService =
    new WebConversionService(this.mvcProperties.getDateFormat());
  this.addFormatters(conversionService);
  return conversionService;
}
//将格式化器添加容器中
protected void addFormatters(FormatterRegistry registry) {
  this.configurers.addFormatters(registry);
}
```

3. 对HttpMessageConverters的支持
   * springmvc用它来转换Http请求和响应的; User_json  User_xml
   * 可以通过@Bean向容器中添加一个我们自定义的HttpMessageConverters,就可以被容器管理使用了;

4.自动注册MessageCodesResolver

* 定义错误代码生成规则

5. 自动注册ConfigurableWebBindingInitializer
   * 初始化所有web数据绑定器对象,比如  请求数据-->Javabean
6. 对静态资源的支持,包括对webjars的支持;
7. 对静态首页index.html的支持;
8. 对自定义Favicon图标的支持;

***

1. 如果想保留springbootMVC的特性,而且还想扩展新的功能(拦截器,格式化器,视图控制器等),你可以在你自定义的webMvcConfigurer类上增加@Configuration注解;
2. 如果你想全面控制springmvc(也就是不使用默认配置),你可以自定义的web配置类上添加@Configuration和@EnableWebMvc注解;

#### 5.扩展springMvc功能

**xml方式扩展一个视图解析器功能**

```xml
<!--配置视图解析器-->
<mvc:view-controller path="/mengxuegu" view-name="success"/>
<!--配置拦截器-->
<mvc:interceptors>
  <mvc:interceptor>
    <mvc:mapping path="/*"/>
    <bean id="intercept" class="实现Interceptor接口的类的完全限定名"></bean>
  </mvc:interceptor>
</mvc:interceptors>
```

注意:配合@ImportResource注解使用

###### 5.1@Configuration扩展mvc功能

由于springboot不建议使用xml配置,因此写配置类来实现

**自定义配置类保留了所有的自动配置,也能扩展我们的功能**

```java
/* 
1.自定义配置类实现WebMvcConfigurer
2.注解@Configuration
3.重写addViewControllers方法,自己新添加视图解析器供容器管理
*/
@Configuration
public class MySpringMvcConfigurer implements WebMvcConfigurer{
@Override
  public void addViewControllers(ViewControllerRegistry registry) {
   // super.addViewControllers(registry);
    //发送 /mengxuegu 请求来到 success.html
    registry.addViewController("/mengxuegu").setViewName("success");
 }
}

//说明:实现一个类时ctl+o可以查看所有可以重写的方法
```

#####5.2@EnableWebMvc全面控制springmvc

```java
/*
使用@Configuration注解,springboot提供的WebMvcAutoConfiguration中默认mvc的配置全部失效
*/
@EnableWebMvc
@Configuration
public class MySpringMvcConfigurer implements WebMvcConfigurer{
@Override
  public void addViewControllers(ViewControllerRegistry registry) {
   // super.addViewControllers(registry);
      //发送 /mengxuegu 请求来到 success.html
    registry.addViewController("/mengxuegu").setViewName("success");
 }
}


/*原理:@EnableWebMvc 将  WebMvcConfigurationSupport 组件导入进来, 使得 WebMvcAutoConfiguration就失效了;
而在 WebMvcAutoConfiguration 上使用了@ConditionalOnMissingBean(WebMvcConfigurationSupport.class),意思是如果没有WebMvcConfigurationSupport,该类才生效
具体源码分析见文档
*/
```

### 五 web项目实战-账单管理系统

**默认前端已经开发好前端页面**

#### 1.初始化项目

##### 1.1创建并引入项目资源

![1572165530587](assets/1572165530587.png)

选择web+thymeleaf

##### 1.2Thymeleaf修改资源路径

优点:使用[^th:href]修改资源路径,  可以自动获取应用名

```xml
<script th:src="@{/js/js.js}" src="../js/js.js"></script>
# 上面会自动获取到应用名 /bill
server.servlet.context-path=/bill

# 说明:如果不配置应用名 则src="/js/js.js"也能获取静态资源,因为springboot已经配置了静态资源访问规则,只要静态资源在resource/static下

```

##### 1.3Thymeleaf引入片段时传入参数

```html
<div th:replace="main/public :: #public_left(activeUri='provider')">
</div>
<!--引入template/main/public.html文件的id='public'的代码片段,并传入参数activeUri='provider'-->

<!--public.html可以通过el表达式接收参数-->
<li th:id="${activeUri == 'provider' ? 'active' : ''}"></li>
```

##### 1.4更改图标和默认访问欢迎页

**1.更改图标**

```properties
classpath:/META-INF/resources/
classpath:/resources/
classpath:/static/
classpath:/public/
/: 当前项目根路径下

在以上路径下添加图标favicon.ico即可使用
```

**2.默认访问欢迎页是login.html**

```java 
//新建自定义配置类,方法内部返回实现WebMvcConfigurer的类,该类增加了自定义视图解析器
//让WebMvcConfigurer被spring容器管理,由于内部自定义了视图解析器,springboot默认的mvc配置类WebMvcAutoConfiguration会检测到自定义控制器并使用它
@Configuration
public class MySpringMvcConfigurer {
  @Bean
  public WebMvcConfigurer webMvcConfigurer() {
    return new WebMvcConfigurer(){
      //添加视图控制
      @Override
      public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("main/login");
        registry.addViewController("/index.html").setViewName("main/login");
     }
   };
 }
}
```

#### 2.国际化信息

##### 2.1springboot国际化步骤

**1.编写国际化配置文件,需要显示的国际内容写到配置中**

```properties
#类路径下创建 i18n 目录存放配置文件(i18n 是“国际化”的简称)
login.properties  (默认国际化文件)
#login_语言代码_国家代码.propertis
login_zh_CN.properties (中文_中国 国际化文件)
login_en_US.properties (英文_美国 国际化文件)
```

*注意:先修改properties问价的字符编码,不然会出现乱码*

![1572194014020](assets/1572194014020.png)

*类路径下创建i18n目录存放配置文件(右键i18n选择new->resource bundle可以同时新建和编写多个properties文件)*

![1572194078801](assets/1572194078801.png)

**2.登录页面中通过#{}获取国际化值**

```HTML
<div class="inputbox">
      <label for="user" th:text="#{login.username}">Username</label>
      <input id="user" type="text" name="username" required/>
    </div>
    <div class="inputbox">
      <label for="mima" th:text="#{login.password}">Password</label>
      <input id="mima" type="password" name="password" required/>
    </div>
    <div class="subBtn">
     Thymeleaf 行内表达式双中括号[[表达式]]（参考12 Inlining）
      <input type="checkbox" /> [[#{login.remember}]]
    </div>
    <br/>
    <div class="subBtn">
      <input type="submit" th:value="#{login.submit}" value="登录" />
      <input type="reset" th:value="#{login.reset}" value="重置"/>
    </div>
```

**3.全局配置文件添加spring.messages.basename = i18n.login,会自动读取i18n.login文件作为国际化信息**

```
说明:springboot 已经自动配置了管理国际化资源文件的组件  MessageSourceAutoConfiguration,该配置类中定义了,会自动寻找类路径下的国际化资源文件的基础名为  messages,如果找到就直接使用,无需配置,因为spring.messages.basename默认为messages 
```

##### 2.2切换国际化

**1.分析切换国际化原理**

* 原理 : LocaleResolver 获取区域信息对象, 来切换国际化信息 (区域信息就是像  zh_CN /  en_US )

```java
public class WebMvcAutoConfiguration {
@Bean
@ConditionalOnMissingBean//如果容器中有LocaleResolver实例,则不使用该默认实例
@ConditionalOnProperty(prefix = "spring.mvc", name = {"locale"})
public LocaleResolver localeResolver() {
  if (this.mvcProperties.getLocaleResolver() == LocaleResolver.FIXED) {
    return new FixedLocaleResolver(this.mvcProperties.getLocale());
 } else {
    //1. 根据请求头来获取区域信息
    AcceptHeaderLocaleResolver localeResolver = new
AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
 }
}
 
//2. 请求头区域信息解析器
public class AcceptHeaderLocaleResolver implements LocaleResolver {  
public Locale resolveLocale(HttpServletRequest request) {
  public Locale resolveLocale(HttpServletRequest request) {
    Locale defaultLocale = this.getDefaultLocale();
    //
    if (defaultLocale != null && request.getHeader("Accept-Language")==null){
      return defaultLocale;
   } else {
      //3. 获取当前收到的请求区域信息, 从而来选择国际化语言
      Locale requestLocale = request.getLocale();
   }
 }
    
    
//说明:LocaleResolver是用来获取请求头区域信息的,而AcceptHeaderLocaleResolver是解析区域信息的,因此我们可以自定义区域信息解析器来改写区域信息给AcceptHeaderLocaleResolver来解析
```

**2.点击链接切换国际化(自定义区域信息解析器)**

* 请求参数中设置区域信息

```html
<div style="margin-left: 100px;">
  <a th:href="@{/index.html(l='zh_CH')}" href="#">中文</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a th:href="@{/index.html(l='en_US')}" href="">English</a>
</div>
```

* 自定义区域信息解析器来进行设置区域信息(原理:不从请求头中获取语言信息,而改为从参数中获取)

  ```java
  /**
  * 自定义解析器来切换国际化信息,
  * 需要再注入到容器器
  * @Auther: www.mengxuegu.com
  */
  public class MyLocaleResolver implements LocaleResolver {
    /**解析区域信息*/
    @Override
    public Locale resolveLocale(HttpServletRequest httpServletRequest) {
      System.out.println("区域信息。。。");
      //获取请求头中的l参数值
      String l = httpServletRequest.getParameter("l");
      //获取浏览器上的区域信息
      Locale locale = httpServletRequest.getLocale();
      //获取当前操作系统 默认的区域信息
  //    Locale locale = Locale.getDefault();
     
      //参数有区域信息，则用参数里的区域信息
      if (!StringUtils.isEmpty(l)) {
        String[] split = l.split("_");
        //参数：语言代码，国家代码
        locale = new Locale(split[0], split[1]);
     }
      return locale;
   }
    @Override
    public void setLocale(HttpServletRequest httpServletRequest,
  HttpServletResponse httpServletResponse, Locale locale) {
   }
  }
  ```

  

* 需要替换mvc自动配置类中区域信息解析器,(返回值与方法名要和下面保持必须一致)

```java
@Configuration
public class MySpringMvcConfigurer{
  //需要替换mvc自动配置类中区域解析器,
  @Bean
  public LocaleResolver localeResolver() {
    return new MyLocaleResolver();
 }
}
```

