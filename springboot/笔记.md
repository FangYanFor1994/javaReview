### 一、构建springboot项目入门

#### 1.使用spring初始化器创建springboot项目

#####1.1步骤

![1571590153462](assets/1571590153462.png)

![1571590186989](assets/1571590186989.png)

![1571590211484](assets/1571590211484.png)

![1571590236127](assets/1571590236127.png)

![1571590271853](assets/1571590271853.png)

##### 1.2访问

```java
编写controller即可访问：（由于引入了web模块，支持springMVC）
默认端口号：8080   

@Controller
public class HelloController {
    @ResponseBody
    @RequestMapping("/hello")
    public String hello(){
        return "Hello World....";
    }
}
```

### 二、springboot核心配置

#### 1.springboot的配置文件类型(properties和yml)

```java
1.application.properties / application.yml
2.配置文件的作用：修改springboot的默认配置；
				springboot有很多默认配置，详见官网：
```

https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#common-application-properties

#### 2.yml语法格式

```yaml
1.key: value 表示一对键值对（冒号后面必须有空格）
2.使用空格缩进表示层级关系，左侧缩进空格数不重要，只要同一层级元素左侧对其即可；
3.字符串默认不加引号
4.对象&Map
	一般写法：
		emp:
		  lastName: xiaomeng
		  age: 22
		  salary: 10000
	行内写法：
		emp: {lastName: xiaomeng, age: 22, salary: 10000}
		
5.数组（List & set）
	一般写法：
		fortes:
		  - java
		  - python
		  - hadoop
	行内写法：
		fortes: [java, python, hadoop]
```

**注意：properties中map和list的写法**

```properties
#对象&map
	emp.map.key1=value1
	emp.map.key2=value2
#list
	emp.list=one,two,three
```

#### 2.@ConfigurationProperties和@Value配置文件注入值的比较

**2.1@ConfigurationProperties配置文件注入值**

```java
@Component
@ConfigurationProperties(prefix = "emp")
public class Emp {
  private String lastName;
  private Integer age;
  private Double salary;
  private Boolean boss;
  private Date birthday;
  private Map map;
  private List list;
    ..getter&setter..
}
```

**2.2@Value配置文件注入值**

```java
  @Value("${emp.last-name}")
  private String lastName;
  @Value("#{10*2}")
  private Integer age;
  @Value("8000")
  private Double salary;
```

**2.3总结@Value 与 @ConfigurationProperties获取值差异**

![1571592548574](assets/1571592548574.png)

注：如果只是某个业务逻辑中需要获取配置文件某个属性值则使用@Value，如果专门使用Javabean和配置文件映射，则使用@ConfigurationProperties

#### 3.@PropertySource用于加载局部配置文件

```java
//PropertySource读取value指定的配置文件而非默认的配置文件
@PropertySource(value = {"classpath:emp.properties"})
@Component
@ConfigurationProperties(prefix = "emp")
@Validated
public class Emp {
  private String lastName;
  private Integer age;
  private Double salary;
  private Boolean boss;
  private Date birthday;
  private Map map;
  private List list;
  //特长
  private Forte forte;
```

#### 4.@ImportResource使用xml配置

```java
//将@ImportResource(locations = {"classpath:spring01.xml"})注解到配置类上，就会读取spring01.xml里面的配置
@ImportResource(locations = {"classpath:spring01.xml"})
@SpringBootApplication
public class SpringBoot02ConfigApplication {
  public static void main(String[] args) {
    SpringApplication.run(SpringBoot02ConfigApplication.class, args);
 }
}
```

#### 5.自定义配置类向容器注入组件

```java
/**
* @Configuration 用于标识当前类是一个配置类, 来表示对应的Spring配置文件
*/
@Configuration
public class EmpConfig {
  /**
  * @Bean 标识的方法用于向容器注入组件
  * 1. 方法的返回值就是注入容器中的组件对象,
  * 2. 方法名是这个组件对象的 id 值
  */
  @Bean
  public EmpService empService2() {
    System.out.println(" @Bean 注解已经将 EmpService 组件注入");
    return new EmpService();
 }
}

//总结：配置类的作用类似于application.xml，@Bean相当于<bean></bean>标示一个类注入到spring容器中，   方法名是<bean id="empService2">中id
```

#### 6.Profile多环境支持

**properties文件激活**

```
创建两个文件  application-dev.properties 与  application-prod.properties；
在主配置文件  application.properties 中指定  spring.profiles.active=dev，即可激活application-dev.properties文件；
```

**yml文件激活**

```yaml
#yaml支持多文档块方式 ---
server:
	port: 8081   # 默认端口号
spring:
    profiles:
        active: prod #激活哪个profile , 当前激活的是 dev 开发环境
---
server:
	port: 8082
spring:
	profiles: dev #指定属于哪个环境, dev 环境时使用
---
server:
	port: 8888
spring:
	profiles: prod #指定属于哪个环境, prod 环境时使用
```

#### 7.配置文件加载位置

```java
1.springboot启动时，会扫描以下位置的application.properties或application.yml作为默认配置文件：
2.高优先级的配置内容会覆盖低优先级的配置内容
```

![1571594139298](assets/1571594139298.png)

### 三、springboot日志配置

#### 1.slf4j+logback的组合形式

```
Spring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置；
spring官网参考文档：
https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#boot-features-logging
```

```properties
1.日志级别（低->高）：
	trace < debug < info < warn <error
2.springboot默认设置级别为info(也称root级别)
3.调整日志级别：
	3.1修改指定包下的日志级别：
		logging.level.com.fy=trace
	3.2设置root级别：
		logging.level.root=debug
```

#### 2.修改日志文件生成路径

**修改生成日志文件两种方式如下**

![1571672547699](assets/1571672547699.png)

**示例：**

```properties
#输出到当前项目根路径下的springboot.log文件中
logging.file=springboot.log
#注：logging.file=D:/springboot.log 也可以将生成日志放入指定磁盘目录

#输出到当前项目所在的磁盘根路径下的/springboot/log目录中的spring.log文件中
logging.path=springboor/log

推荐使用logging.file可以指定路径和文件名，而logging.path不能指定文件名
```

#### 3.修改日志输出格式

```properties
#日志输出格式说明：
	# %d 输出日期时间，
	# %thread 输出当前线程名，
	# %-5level 输出日志级别，左对齐5个字符宽度，
	# %logger{50} 输出全类名最长50个字符，超过按照句点分割，
	# %msg 日志信息
	# %n 换行符
	
#修改控制台输出的日志格式
logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n

#修改文件中输出的日志格式
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} >>> [%thread] >>> %-5level >>>
%logger{50} >>> %msg%n
```

#### 4.自定义日志配置

1）在 spring-boot-2.0.6.RELEASE.jar! \org\springframework\boot\logging\logback\base.xml 做了日志的
默认配置

```xml
<included>
 <!--日志格式默认规定-->
 <include resource="org/springframework/boot/logging/logback/defaults.xml" />
 <!--日志文件默认生成路径-->
 <property name="LOG_FILE"
value="${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}"/>
 <!--控制台日志信息默认配置-->
  <include resource="org/springframework/boot/logging/logback/console-appender.xml"
/>
 <!--文件中日志信息默认配置-->
 <include resource="org/springframework/boot/logging/logback/file-appender.xml" />
  <!--日志级别默认为： info -->
  <root level="INFO">
   <appender-ref ref="CONSOLE" />
   <appender-ref ref="FILE" />
 </root>
</included>
```

2)如果springboot的日志功能无法满足我们的需求（比如异步日志记录等），我们可以自己定义日志配置文件

```
在类路径下存放对应的日志框架配置文件即可，springboot 就不会使用它默认的日志配置了；
```

**在resource目录下创建logback.xml文件如下：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--梦学谷 www.mengxuegu.com

scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。
debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。
-->
<configuration scan="false" scanPeriod="60 seconds" debug="false">
    <!-- 定义日志的根目录 -->
    <property name="LOG_HOME" value="/logs/log" />
    <!-- 定义日志文件名称 -->
    <property name="appName" value="mengxuegu-spring-boot"></property>
    <!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 -->
    <appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        <!--
			日志输出格式说明：
				    %d 		输出日期时间
				    %thread 输出当前线程名
				    %-5level  	输出日志级别，左对齐5个字符宽度
				    %logger{50} 输出全类名最长50个字符，超过按照句点分割
				    %msg  	日志信息
				    %n    	换行符
        -->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} - [%thread] - %-5level - %logger{50} - %msg%n</pattern>
        </layout>
    </appender>

    <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 -->  
    <appender name="appLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 指定日志文件的名称 -->
        <file>${LOG_HOME}/${appName}.log</file>
        <!--
        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名
        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。
        -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--
				滚动时产生的文件的存放位置及文件名称 %d{yyyy-MM-dd}：按天进行日志滚动 
				%i：当文件大小超过maxFileSize时，按照i进行文件滚动
            -->
            <fileNamePattern>${LOG_HOME}/${appName}-%d{yyyy-MM-dd}-%i.log</fileNamePattern>
            <!-- 
            可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。
			假设设置每天滚动，且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。
			注意，删除旧文件是，那些为了归档而创建的目录也会被删除。
            -->
            <MaxHistory>365</MaxHistory>
            <!-- 
            当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy
            -->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <!-- 日志输出格式： -->     
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [ %thread ] - [ %-5level ] [ %logger{50} : %line ] - %msg%n</pattern>
        </layout>
    </appender>

    <!-- 
		logger主要用于存放日志对象，也可以定义日志类型、级别
		name：表示匹配的logger类型前缀，也就是包的前半部分
		level：要记录的日志级别，包括 TRACE < DEBUG < INFO < WARN < ERROR
		additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，
		false：表示只用当前logger的appender-ref，true：
		表示当前logger的appender-ref和rootLogger的appender-ref都有效
    -->
    <!-- hibernate logger -->
    <logger name="com.mengxuegu" level="debug" />
    <!-- Spring framework logger -->
    <logger name="org.springframework" level="debug" additivity="false"></logger>


    <!-- 
    root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，
    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 
    -->
    <root level="info">
        <appender-ref ref="stdout" />
        <appender-ref ref="appLogAppender" />
    </root>
</configuration> 
```

