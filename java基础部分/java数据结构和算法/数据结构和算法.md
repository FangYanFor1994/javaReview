### 1.数据结构和算法概述

#### 1.1数据结构和算法的关系

```java
1.程序 = 数据结构 + 算法
2.数据结构是算法的基础，想要学好算法，必须要把数据结构学到位。
3.数据结构主要分为 线性结构 和 非线性结构。
```

#### 1.2线性结构和非线性结构

```java
1.线性结构
	1）线性结构是最常用的数据结构，特点是数据元素之间存在一对一的线性关系。
	2）线性结构的两种不同存储结构，即顺序存储结构(数组)和链式存储结构（链表）。顺序存储结构中存储元素是连续的，链表中的存储元素不一定是连续的（元素节点中存放数据元素以及相邻元素的地址信息）
	3）线性结构常见的有：数组、队列、链表和栈。

2.非线性结构
	非线性结构包括：二维数组、多维数组、广义表、数据结构、图结构。
```

### 2.稀疏数组和队列

#### 2.1稀疏数组sparsearray

##### 2.1.1需求

* 编写的五子棋程序中，有存盘退出和续上盘的功能。

![1582823513644](assets/1582823513644.png)

* 分析问题： 因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据->稀疏数组

##### 2.1.2稀疏数组的处理方法

1）记录数组一共几行几列，有多少个不同的值

2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序规模。

![1582823708198](assets/1582823708198.png)

##### 2.1.3应用实例

1）使用稀疏数组来保留类似前面的二维数组；

2）把稀疏数组存盘，并且可以重新恢复为原来的二维数组；

3）思路分析，如下

![1582823903907](assets/1582823903907.png)

4）代码实现

```java
public class ParsearrayDemo {
    public static void main(String[] args) {
        //1.初始化二位数组
        int[][] chess = new int[11][11];
        chess[1][2] = 1;
        chess[2][3] = 2;
        //打印二维数组
        System.out.println("打印二位数组");
        for (int i = 0; i<11; i++){
            for (int j = 0; j<11; j++){
                System.out.printf("%d\t", chess[i][j]);
            }
            System.out.println();
        }
        //2.二维数组转稀疏数组
        int sum = 0; //记录二位数组总共有多少个不同的值
        for (int i = 0; i<11; i++){
            for (int j = 0; j<11; j++){
                if(chess[i][j] != 0){
                    sum++;
                }
            }
        }
        int[][] parsearray = new int[sum + 1][3];
        parsearray[0][0] = 11;
        parsearray[0][1] = 11;
        parsearray[0][2] = sum;
        int n = 0;
        for (int i = 0;i<11;i++){
            for (int j = 0;j<11;j++){
                if(chess[i][j]!=0){
                    n++;
                    parsearray[n][0] = i;
                    parsearray[n][1] = j;
                    parsearray[n][2] = chess[i][j];
                }
            }
        }
        //打印稀疏数组
        System.out.println("打印稀疏数组");
        for (int i = 0; i<parsearray.length; i++){
            for (int j = 0; j<3;j++){
                System.out.printf("%d\t", parsearray[i][j]);
            }
            System.out.println();
        }

        //3.稀疏数组转二维数组
        int[][] chess2 = new int[parsearray[0][0]][parsearray[0][1]];
        for (int i = 1; i<parsearray.length; i++){
            chess2[parsearray[i][0]][parsearray[i][1]] = parsearray[i][2];
        }
        //打印还原后的二维数组
        System.out.println("打印还原后的二位数组");
        for (int[] ches : chess2){
            for (int data : ches){
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
    }
}

```

#### 2.2队列

##### 2.2.1队列介绍

```java
1.队列是一个有序列表，可以用数组或链表实现；
2.遵循先入先出的原则；
3.示意图如下（使用数组模拟队列示意图）：
```

![1583082802658](assets/1583082802658.png)

##### 2.2.2数组模拟队列思路

```java
1.数组模拟队列，数组的初始长度即为队列的最大容量；
2.队列的输入和输出是从尾和头来处理，因此需要两个变量rear,front分别记录队列尾和头的下标；front随着数据的输出而改变，rear随着数据的输入而改变；
3.当我们存数据到队列时有两个步骤：
	1）将尾指针向后移：rear+1,当rear==front(空)
    2）若尾指针小于maxSize-1,则将数据存入rear所指的数组元素中，否则无法存入数据；rear == maxSize-1(满)；
4.注意：front指向头部数据的前一个位置，rear指向尾部数据的位置；上图第三个front应该为1
```

代码实现：

```java
public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        //创建一个队列
        ArrayQueen queue = new ArrayQueen(3);
        char key = ' '; //接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s,显示队列");
            System.out.println("e,退出程序");
            System.out.println("a,添加数据");
            System.out.println("g,从队列取出数据");
            System.out.println("h,查看头部数据");
            key = scanner.next().charAt(0); //接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    try {
                        System.out.println("请输入要添加的数据");
                        int i = scanner.nextInt();
                        queue.addQueue(i);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'g':
                    try {
                        int res = queue.getQueue();
                        System.out.println("取出的数据是" + res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int n = queue.headQueue();
                        System.out.println("头数据是"+n);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                    default:
                        break;
            }
        }
        System.out.println("程序退出~");
    }
}

//使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueen{
    private int maxSize; //数组最大容量
    private int front; //队列头
    private int rear; //队列尾
    private int[] arr; //该数组用于存放数据，模拟队列

    //创建队列的构造器
    public ArrayQueen(int arryMaxSize){
        maxSize = arryMaxSize;
        arr = new int[maxSize];
        front = -1; //指向队列的头部前一个位置
        rear = -1; //指向队列尾的数据
    }

    //判断队列是否已满
    public boolean isFull(){
        return rear == maxSize - 1;
    }

    //判断判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    //添加数据到队列
    public void addQueue(int a){
        if(isFull()){
            throw new RuntimeException("队列已满，不能添加数据");
        }
        rear ++;
        arr[rear] = a;
    }

    //获取队列数据，出队列
    public int getQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列已空，不能取数据");
        }
        front ++;
        return arr[front];
    }

    //显示队列所有数据
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列是空的，没有数据~");
            return;
        }
        for (int i = 0; i<arr.length; i++){
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    //显示队列的头部,注意不是出队列
    public int headQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列是空的，没有头部数据");
        }
        return arr[front+1];
    }
}
```

问题分析及优化：

​	1）目前的数组使用一次就不能用了，没有达到复用的效果；

​	2）将这个队列使用算法，改造成一个环形队列   取模 %

##### 2.2.3数组模拟环形队列

对前面的数组模拟队列优化，充分利用数组，因此将数组看作是一个环形的。（通过取模的方式实现即可）。

分析说明：

![1583163961810](assets/1583163961810.png)

代码实现：

```java
public class CircleQueueDemo {
    public static void main(String[] args) {
        //测试
        //创建一个队列
        CircleArrayQueue queue = new CircleArrayQueue(4);
        char key = ' '; //接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s,显示队列");
            System.out.println("e,退出程序");
            System.out.println("a,添加数据");
            System.out.println("g,从队列取出数据");
            System.out.println("h,查看头部数据");
            key = scanner.next().charAt(0); //接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    try {
                        System.out.println("请输入要添加的数据");
                        int i = scanner.nextInt();
                        queue.addQueue(i);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'g':
                    try {
                        int res = queue.getQueue();
                        System.out.println("取出的数据是" + res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int n = queue.headQueue();
                        System.out.println("头数据是"+n);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~");
    }
}

//用数组创建一个环形队列
class CircleArrayQueue{
    private int maxSize;
    private int front;
    private int rear;
    private int[] arr;

    public CircleArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    //判断队列是否已满
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }
    //判断队列是否已空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int a){
        if(isFull()){
            System.out.println("队列已满，不能添加数据~");
            return;
        }
        arr[rear] = a;
        rear = (rear + 1) % maxSize;
    }
    //获取队列数据
    public int getQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列已空，不能取数据~");
        }
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }
    //显示队列所有数据
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列时空的，没法显示数据~");
            return;
        }
        for(int i = front; i < front + size(); i++){
            System.out.printf("arr[%d]=%d\n", i%maxSize, arr[i%maxSize]);
        }
    }
    //显示队列的头，注意不是取数据
    public int headQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列时空的，没有头数据~");
        }
        return arr[front];
    }


    //当前队列有多少有效数据
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }
}

```

### 3.链表

#### 3.1链表（Linked List）介绍

链表是有序的的列表，但是每个节点在内存中是不连续的

![1583169034523](assets/1583169034523.png)

```java
1.链表是以节点方式来存储，是链式存储；
2.每个节点包含data域，next域：指向下一个节点；
3.链表的各个节点不一定是连续存储；
4.链表分为带头结点的链表和不带头节点的链表，根据实际需求来确定；
```

#### 3.2单链表的实例应用

```java
问题：
使用带head头的单向链表实现水浒英雄排行榜管理完成对英雄人物的增删改查操作。
1）第一种添加方式，添加英雄时直接在链表尾添加；
2）第二种添加方式，根据排名，将英雄添加到指定的位置，如果有这个排名则添加失败且给出提示信息；
3）修改节点
4）删除节点
```

代码实现：

```java
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        //测试单向链表
        HeroNode heroNode = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode1 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode2 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode3 = new HeroNode(4, "公孙胜", "入云龙");

        SingleLinkedList singleLinkedList = new SingleLinkedList();
        /*singleLinkedList.addNode(heroNode);
        singleLinkedList.addNode(heroNode1);
        singleLinkedList.addNode(heroNode2);
        singleLinkedList.addNode(heroNode3);*/
        //带编号添加
        singleLinkedList.addNodeByOrder(heroNode);
        singleLinkedList.addNodeByOrder(heroNode3);
        singleLinkedList.addNodeByOrder(heroNode2);
        singleLinkedList.addNodeByOrder(heroNode1);
        singleLinkedList.addNodeByOrder(heroNode2);

        singleLinkedList.showSingleLinkedList();
        
        //测试修改
        HeroNode node = new HeroNode(2, "卢员外", "玉麒麟~~");
        singleLinkedList.update(node);
        System.out.println("修改以后的链表如下：");
        singleLinkedList.showSingleLinkedList();
        
        //测试删除节点
        singleLinkedList.delete(1);
        singleLinkedList.delete(4);
        singleLinkedList.delete(2);
        System.out.println("删除以后的链表如下：~");
        singleLinkedList.showSingleLinkedList();
    }
}

class SingleLinkedList{
    //初始化一个头结点,头节点不存储数据
    private HeroNode head = new HeroNode(0, "", "");

    //添加节点（不考虑编号）
    //1.找到当前链表的最后节点
    //2.将最后节点的next指向新的节点
    public void addNode(HeroNode heroNode){
        //因为head节点不能动，因此我们需要一个辅助遍历temp
        HeroNode temp = head;
        while (true){
            if(temp.next == null){
                break;
            }
            temp = temp.next;
        }
        temp.next = heroNode;
    }
    
    //添加节点（考虑编号，若编号存在提示添加不进去）
    public void addNodeByOrder(HeroNode heroNode){
        //遍历辅助变量
        HeroNode temp = head;
        //是否有相同的编号
        boolean flag = false;
        while(true){
            if(temp.next == null){
                break;
            }
            if(temp.next.no > heroNode.no){
                break;
            }else if(temp.next.no == heroNode.no){
                flag = true;
            }
            temp = temp.next;  //指针后移
        }

        if(flag){
            System.out.printf("编号%d已经存在，无法添加~", heroNode.no);
        }else{
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }
    
    //修改节点
    public void update(HeroNode heroNode){
        HeroNode temp = head;
        //是否找到相同的节点供修改
        boolean flag = false;
        while (true){
            if(temp.next == null){
                break;
            }
            if(temp.next.no == heroNode.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            temp.next.name = heroNode.name;
            temp.next.nickName = heroNode.nickName;
        }else{
            System.out.printf("没有找到编号为%d的节点\n,不能修改~", heroNode.no);
        }

    }
    
    //删除节点
    public void delete(int no){
        HeroNode temp = head;
        boolean flag = false;
        while(true){
            if(temp.next == null){
                break;
            }
            if(temp.next.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            temp.next = temp.next.next;
        }else{
            System.out.printf("没有找到编号为%d的节点，不能删除\n", no);
        }
    }
    

    //显示链表
    public void showSingleLinkedList(){
        HeroNode temp = head;
        while(true){
            if(temp.next == null){
                break;
            }
            System.out.println(temp.next.toString());
            temp = temp.next;
        }
    }
}

//创建HeroNode,每一个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;

    public HeroNode(int no, String name, String nickName){
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}

```

#### 3.3单链表面试题（新浪、百度、腾讯）

1）求单链表中有效节点个数

```java
//单链表中有效节点个数（不能统计头节点）
    public int getLength(HeroNode head){
        HeroNode cur = head.next;
        int i = 0;
        while(cur != null){
            cur = cur.next;
            i++;
        }
        return i;
    }
```

2）查找单链表中倒数第k个节点

```java
//查找单链表中倒数第k个节点
    //1.先遍历查出链表的有效节点个数length
    //2.倒数第K个就是正数第length-k个
    public static HeroNode findLastIndexNode(HeroNode head, int index){
        int length = getLength(head);
        if(index <= 0 || index > length){
            return null;
        }
        HeroNode cur = head.next; //length=3,index=1, 从第一个到第三个需要遍历两次，3-1正确
        for(int i = 0; i < length-index; i++){
            cur = cur.next;
        }
        return cur;
    }
```

3）单链表反转（腾讯面试题）

思路分析：

![1583337343969](assets/1583337343969.png)

代码实现：

```java
//腾讯面试题：单链表的反转
    //思路：1.新建一个单链表的头节点ReverseHead  2.遍历原来的链表，每取出一个节点都放在新链表的最前面 3.将原来的链表头的下一个节点指向新链表头的第一个节点
    public static HeroNode reverseList(HeroNode head){
        if(head.next == null || head.next.next == null){
            return head;   //空链表或只有一个节点的链表直接返回
        }
        HeroNode reverseHead = new HeroNode(0, "", "");
        HeroNode cur = head.next; //辅助变量（循环指针）
        HeroNode next = null; //指向当前节点的下一个节点
        while (cur != null){
            next = cur.next; //注意：把当前节点及后面的节点保存,供后面指针后移使用
            cur.next = reverseHead.next;
            reverseHead.next = cur;
            cur = next;
        }
        head.next = reverseHead.next;
        return head;
    }
```

4）从尾到头打印链表（百度面试题，推荐用栈实现)

代码实现：

```java
 //百度面试题：从尾到头打印单链表(使用栈)
    public static void reversePrint(HeroNode head){
        if(head.next == null){
            return; //链表为空
        }
        //创建一个栈，将链表各个节点顺序压入栈中，先进后出完成倒序
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur = head.next;
        while (cur != null){
            stack.push(cur);
            cur = cur.next;
        }
        while (stack.size() > 0){
            System.out.println(stack.pop().toString());
        }
    }
```

#### 3.4双向链表应用实例

![1583416588176](assets/1583416588176.png)

**对上图说明：**

1.*遍历：*方法和单链表一样，只是可以向前也可以向后查找；

2.*添加（默认添加到双向链表的最后）*：

​	1）先找到双向链表的最后这个节点

​	2）temp.next = newHeroNode

​	3)newHeroNode.pre = temp

3.*修改：*思路和原来单链表一样

4.*删除*

​	1）因为是双链表，因此可以实现自我删除某个节点；

​	2）直接找要删除的节点，比如temp

​	3）temp.pre.next = temp.next

​	4)temp.next.pre = temp.pre

**双向链表代码实现：**

```java
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        //测试双向链表
        System.out.println("双向链表的测试~");

        HeroNode2 heroNode = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 heroNode1 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 heroNode2 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 heroNode3 = new HeroNode2(4, "公孙胜", "入云龙");

        //创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.addNode(heroNode);
        doubleLinkedList.addNode(heroNode1);
        doubleLinkedList.addNode(heroNode2);
        doubleLinkedList.addNode(heroNode3);
        doubleLinkedList.showDoubleLinkedList();

        HeroNode2 newNode = new HeroNode2(3, "wu用", "智多星~");
        doubleLinkedList.update(newNode);
        System.out.println("测试修改~");
        doubleLinkedList.showDoubleLinkedList();

        doubleLinkedList.delete(3);
        doubleLinkedList.delete(4);
        System.out.println("测试删除~");
        doubleLinkedList.showDoubleLinkedList();
    }


}


class DoubleLinkedList{
    //初始化一个头结点,头节点不存储数据
    private HeroNode2 head = new HeroNode2(0, "", "");

    public HeroNode2 getHead() {
        return head;
    }

    //添加节点（默认添加到链表的最后）
    //1.找到当前链表的最后节点
    //2.将最后节点的next指向新的节点
    //3.将新节点的pre指向原最后一个节点
    public void addNode(HeroNode2 heroNode){
        //因为head节点不能动，因此我们需要一个辅助遍历temp
        HeroNode2 temp = head;
        while (true){
            if(temp.next == null){
                break;
            }
            temp = temp.next;
        }
        temp.next = heroNode;
        heroNode.pre = temp;
    }

    //修改节点
    public void update(HeroNode2 heroNode){
        HeroNode2 temp = head;
        //是否找到相同的节点供修改
        boolean flag = false;
        while (true){
            if(temp.next == null){
                break;
            }
            if(temp.next.no == heroNode.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            temp.next.name = heroNode.name;
            temp.next.nickName = heroNode.nickName;
        }else{
            System.out.printf("没有找到编号为%d的节点\n,不能修改~", heroNode.no);
        }

    }

    //删除节点(双链表可以实现自我删除)
    public void delete(int no){
        HeroNode2 temp = head.next;
        boolean flag = false;
        while(true){
            if(temp == null){
                break;
            }
            if(temp.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            if(temp.next != null){ //如果是删除最后一个节点
                temp.next.pre = temp.pre;
            }
            temp.pre.next = temp.next;
        }else{
            System.out.printf("没有找到编号为%d的节点，不能删除\n", no);
        }
    }


    //显示链表
    public void showDoubleLinkedList(){
        HeroNode2 temp = head;
        while(true){
            if(temp.next == null){
                break;
            }
            System.out.println(temp.next.toString());
            temp = temp.next;
        }
    }
}

//创建HeroNode,每一个HeroNode对象就是一个节点
class HeroNode2{
    public int no;
    public String name;
    public String nickName;
    public HeroNode2 pre;
    public HeroNode2 next;

    public HeroNode2(int no, String name, String nickName){
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

#### 3.5单向环形链表（约瑟夫环）

1. 约瑟夫（Josephu）问题概要：

   ```java
   问题：
   	设编号为1,2，...,n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止，由此产生一个出队编号的序列。
   提示：
   	用一个不带头节点的循环链表来处理josephu问题：先构建一个有n个节点的单循环链表，然后由k点起从1开始计数，记到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，直到最后一个节点从链表中删除，算法结束。
   ```

   思路分析：

   ![1583431793967](assets/1583431793967.png)

   

   代码示例：

   ```java
   public class Josephu {
       public static void main(String[] args) {
           //测试环形链表
           CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
           circleSingleLinkedList.addBoys(5);
           circleSingleLinkedList.list();
   
           //测试约瑟夫问题
           circleSingleLinkedList.countBoy(1,2,5);
       }
   }
   
   //构建一个单向链表环
   class CircleSingleLinkedList{
       //一个辅助变量，该变量指向第一个节点，因为每增加一个节点都需要指向第一个节点，有变量指向第一个节点才可以操作
       Boy first = null;
   
       //添加节点
       public void addBoys(int count){
           if(count < 1){
               System.out.println("输入参数有误~");
               return;
           }
           //辅助变量（指针），作用类似first，帮助构建环形链表
           Boy curBoy = null;
           for(int i = 1; i<=count; i++){
               Boy boy = new Boy(i);
               if(i == 1){
                   first = boy;
                   curBoy = boy;
                   first.setNext(first);
               }else{
                   curBoy.setNext(boy);
                   curBoy = boy;
                   curBoy.setNext(first);
               }
           }
       }
   
       //遍历环形链表
       public void list(){
           if(first == null){
               System.out.println("链表是空的~");
               return;
           }else {
               //遍历指针
               Boy curBoy = first;
               while(true){
                   System.out.printf("当前小孩编号是%d \n", curBoy.getNo());
                   curBoy = curBoy.getNext();
                   if(curBoy == first)
                       return;
               }
           }
       }
   
   
   
       /**
        * //约瑟夫问题，根据用户输入打印出小孩出圈顺序
        * 说明：数到的小孩要出圈，相当于删除节点，由于是单向链表，因此需要一个辅助指针指在first的前一个节点，帮助删除first到达的节点
        * @param startNo 第几个小孩开始数数
        * @param countNum 数几下
        * @param nums 最初有几个小孩在圈中
        */
       public void countBoy(int startNo, int countNum, int nums){
           //参数校验
           if(first == null || countNum < 1 || startNo < 1 || startNo > nums){
               System.out.println("参数输入有误~");
               return;
           }
           //创建helper指针，指在最后一个节点，辅助删除节点
           Boy helper = first;
           while (true){
               if(helper.getNext() == first){
                   break;
               }
               helper = helper.getNext();
           }
           //将指针移向开始位置k-1
           for(int j = 0; j<startNo-1;j++){
               first = first.getNext();
               helper = helper.getNext();
           }
           //开始数数，first和helper同时移动，到第m个删除
           while(first != helper){
               for(int i = 0; i<countNum-1; i++){
                   first = first.getNext();
                   helper = helper.getNext();
               }
               //first到达第m个数，删除
               System.out.printf("该次出圈的是编号%d \n", first.getNo());
               first = first.getNext();
               helper.setNext(first);
           }
           System.out.println("最后一位是编号"+first.getNo());
       }
   }
   
   //构建一个小孩类
   class Boy{
       private int no;
       private Boy next;
   
       public Boy(int no){
           this.no = no;
       }
       public int getNo() {
           return no;
       }
   
       public void setNo(int no) {
           this.no = no;
       }
   
       public Boy getNext() {
           return next;
       }
   
       public void setNext(Boy next) {
           this.next = next;
       }
   }
   
   ```

   

### 4.栈

#### 4.1栈的介绍

```java
1.栈是一个先入后出的有序列表。
2.栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端为变化的一端，称为栈顶（top），另一端为固定的一端，称为栈底（Bottom）。
3.出栈和入栈如下图所示：
```

![1583514064476](assets/1583514064476.png)

#### 4.2栈的快速入门

1.实现思路：

![1583514111081](assets/1583514111081.png)

2.代码实现：

```java
public class ArrayStackDemo {
    public static void main(String[] args) {
        //测试栈
        ArrayStack arrayStack = new ArrayStack(4);
        Scanner scanner = new Scanner(System.in);
        String key = ""; //接收键盘录入数据
        boolean loop = true; //控制程序是否退出
        while(loop){
            System.out.println("show:显示栈");
            System.out.println("exist:退出程序");
            System.out.println("push:压栈");
            System.out.println("pop:弹栈");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key){
                case "show":
                    try {
                        arrayStack.list();
                    }catch (Exception e){
                        //TODO handler
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exist":
                    scanner.close();
                    loop = false;
                    break;
                case "push":
                    System.out.println("请输入一个数：");
                    int i = scanner.nextInt();
                    arrayStack.push(i);
                    break;
                case "pop":
                    try{
                        int value = arrayStack.pop();
                        System.out.printf("弹出数据是%d \n", value);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~");
    }
}

//模拟栈
class ArrayStack{
    private int top = -1;  //栈顶
    private int[] stack; //数组模拟栈
    private int maxSize; //长度

    public ArrayStack(int maxSize){
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //判断栈为空
    public boolean isEmpty(){
        return top == -1;
    }
    //判断栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }
    //压栈
    public void push(int value){
        if(isFull()){
            System.out.println("栈满，无法添加数据~");
            return;
        }
        top ++;
        stack[top] = value;
    }
    //弹栈
    public int pop(){
        if(isEmpty()){
            throw new RuntimeException("栈空，没有数据可取~");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //遍历栈 从栈顶开始显示数据
    public void list(){
        if(isEmpty()){
            throw new RuntimeException("栈空，没有数据遍历~");
        }
        for(int i = top; i >= 0; i--){
            System.out.printf("stack[%d]=%d \n", i, stack[i]);
        }
//        while (top != -1) { //错误：如果用top遍历，遍历完栈也就空了，top不能动
//            System.out.printf("stack[%d]=%d \n", top, stack[top]);
//            top--;
//        };
    }
}

```

#### 4.3栈实现综合计算器（中缀表达式）

* 思路分析

![1583680768518](assets/1583680768518.png)

* 代码实现

```java
public class ArrayStackDemo {
    public static void main(String[] args) {
        //栈模拟综合计算器
        String expression = "7*2*2-5+1-5+3*41";
        ArrayStack numStack = new ArrayStack(10);
        ArrayStack operStack = new ArrayStack(10);
        int index = 0;  //索引，用来遍历表达式
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' '; //每次扫描的结果
        String keepNum = ""; //拼接多位数
        while (true){
            ch = expression.substring(index, index + 1).charAt(0);
            //如果ch是运算符
            if(operStack.isOper(ch)){
                if(operStack.isEmpty()){ //如果运算符栈为空直接放入
                    operStack.push(ch);
                }else { //如果不为空，与栈顶运算符比较，如果优先级高于栈顶直接放入，优先级低于或等于栈顶，则弹出栈顶运算符和数据栈的两个数据进行计算
                    if(operStack.priority(ch) > operStack.priority(operStack.peek())){
                        operStack.push(ch);
                    }else {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = operStack.cal(num1, num2, oper);
                        numStack.push(res);
                        operStack.push(ch);
                    }
                }
            }else { //如果不是运算符则直接放入numStack
                //numStack.push(ch - 48);
                //多位数处理
                keepNum += ch;
                if(index == expression.length() - 1){
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    //判断下一位字符是运算符的话，将keepNum直接入栈
                    if(operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))){
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }
            }
            index++;
            if(index == expression.length()){
                break;
            }
        }

        //表达式扫描完后，此时运算符栈中的栈顶运算优先级肯定大于等于下面的优先级，因此顺序弹出数据和运算符进行运算
        while (true) {
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = operStack.cal(num1, num2, oper);
            numStack.push(res);
            if(operStack.isEmpty()){
                break;
            }
        }
        System.out.printf("%s=%d", expression, numStack.pop());

    }
}

//模拟栈
class ArrayStack{
    private int top = -1;  //栈顶
    private int[] stack; //数组模拟栈
    private int maxSize; //长度

    public ArrayStack(int maxSize){
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //判断栈为空
    public boolean isEmpty(){
        return top == -1;
    }
    //判断栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }
    //压栈
    public void push(int value){
        if(isFull()){
            System.out.println("栈满，无法添加数据~");
            return;
        }
        top ++;
        stack[top] = value;
    }
    //弹栈
    public int pop(){
        if(isEmpty()){
            throw new RuntimeException("栈空，没有数据可取~");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //遍历栈 从栈顶开始显示数据
    public void list(){
        if(isEmpty()){
            throw new RuntimeException("栈空，没有数据遍历~");
        }
        for(int i = top; i >= 0; i--){
            System.out.printf("stack[%d]=%d \n", i, stack[i]);
        }
//        while (top != -1) { //错误：如果用top遍历，遍历完栈也就空了，top不能动
//            System.out.printf("stack[%d]=%d \n", top, stack[top]);
//            top--;
//        };
    }


    //*************************栈实现综合计算器用到的方法*********************************
    //判断取出的字符是否是运算符+-*/
    public boolean isOper(char ch){
        return ch == '+' || ch == '-' || ch == '*' || ch == '/';
    }
    //查看栈顶的元素
    public int peek(){
        return stack[top];
    }
    //当前运算符的优先级
    public int priority(int oper){
        if(oper == '*' || oper == '/'){
            return 1;
        }else if(oper == '+' || oper == '-'){
            return 0;
        }else{
            return -1;
        }
    }
    //计算结果
    public int cal(int num1, int num2, int oper){
        int res = 0; //计算结果
        switch (oper){
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
}

```

#### 4.4逆波兰计算器

```java
要求：
	已知一个逆波兰表达式计算其值？
解题思路：
	1.创建一个栈用于存放计算过程的数字和符号；
	2.遍历表达式，1）如果是数字则直接入栈 2）如果是运算符，则弹出栈顶和次栈顶数据进行运算，并将运算结果入栈
	3.遍历完成后栈中的数字就是计算结果。
```

代码实现：

```java
public class PolandNotation {
    public static void main(String[] args) {
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";
        //思路：1.先将表达式放入list中
        //      2.将list传给一个方法，配合栈完成计算
        List<String> list = getListString(suffixExpression);
        int result = calculate(list);
        System.out.println("4 5 * 8 - 60 + 8 2 / + 的结果是：" + result);
    }

    //将表达式字符串转为ArrayList
    public static List<String> getListString(String suffixExpression){
        String[] s = suffixExpression.split(" ");
        List<String> list = Arrays.asList(s);
        return list;
    }

    //对波兰表达式转成的list进行计算
    public static int calculate(List<String> list){
        Stack<String> stack = new Stack<>();
        for (String item : list) {
            if(item.matches("\\d+")){ //匹配的是数字，直接入栈
                stack.push(item);
            }else{ //匹配的是运算符则弹出两个数进行计算
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if(item.equals("+")){
                    res = num1 + num2;
                }else if(item.equals("-")){
                    res = num1 - num2;
                }else if(item.equals("*")){
                    res = num1 * num2;
                }else if (item.equals("/")){
                    res = num1 / num2;
                }else{
                    throw new RuntimeException("输入的运算符有误！");
                }
                stack.push(res + "");
            }
        }
        //遍历完成，最后留在栈中的数就是表达式结果
        return Integer.parseInt(stack.pop());
    }
}

```

#### 4.5中缀表达式转后缀表达式（逆波兰表达式）

1. 具体步骤如下

```properties
1.初始化两个栈s1和s2,s1用来存放运算符，s2用来存放数值；
2.从左向右扫描中缀表达式；
3.遇到数值，直接入栈s2；
4.遇到运算符时：
	1）如果s1为空，或者栈顶运算符为“（”，或者当前运算符优先级比栈顶优先级高，  则直接入栈s1；
	2）如果当前运算符优先级小于或等于栈顶运算符优先级，将s1栈顶运算符弹出压入s2中。 重复步骤4
5.遇到括号时：
	1）如果是左括号“（”，直接压入s1;
	2)如果是右括号“）”,则依次弹出s1栈顶的运算符并压入s2，直至遇到“（”为止，并把这一对括号舍弃；
6.重复步骤2-5，直到表达式最右边；
7.将s1中剩余的运算符依次弹出并压入s2;
8.依次弹出s2中的元素，结果的逆序即是中缀表达式对应的后缀表达式；
```

代码实现：

```java
public class PolandNotation {
    public static void main(String[] args) {
        String expression = "1+((2+3)*4)-5";
        //将表达式转为list
        List<String> list = toInfixExpression(expression);
        System.out.println(list);
        //中缀表达式对应的list转为后缀表达式
        List<String> suffixList = toSuffixExpression(list);
        System.out.println(suffixList);
        //将后缀表达式计算结果
        int res = calculate(suffixList);
        System.out.println("计算结果是：" + res);
    }

    //将表达式转为ArrayList
    public static List<String> toInfixExpression(String expression){
        int index = 0; //遍历指针
        String str = ""; //从表达式中取出的字符
        String num = ""; //处理多位数
        ArrayList<String> list = new ArrayList<>();
        while(index < expression.length()){
            str = expression.substring(index,index+1);
            if(!str.matches("\\d+")){ //如果是符号直接加入到list
                list.add(str);
                index++;
            }else{ //如果是数据，判断是否多位数
                num = ""; //每次添加数据之前置空
                while(index < expression.length() && (str = expression.substring(index,index+1)).matches("\\d+")){
                    num += str;
                    index++;
                }
                list.add(num);
            }
        }
        return list;
    }
    
    //将中缀表达式转为逆波兰表达式
    public static List<String> toSuffixExpression(List<String> list){
        //定义两个栈s1存放操作符，s2存放后缀表达式
        Stack<String> s1 = new Stack<>();
        List<String> s2 = new ArrayList<>();
        //遍历中缀表达式的list
        for(String item : list){
            if(item.matches("\\d+")){ //1.如果是数据直接入s2
                s2.add(item);
            }else if(item.equals("(")){ //2.如果是左括号直接入S1
                s1.push(item);
            }else if(item.equals(")")){ //3.如果是右括号，则依次将s1中的符号弹出压入到s2中直至遇到小括号，并舍弃
                while(!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop(); //弹出小括号
            }else{ //4.如果是运算符,1)s1为空或栈顶为"("或当前符号优先级高于栈顶符号，则直接入栈；否则弹出栈顶符号到s2,继续比
                while(s1.size() > 0 && !s1.peek().equals("(") && Operation.getValue(s1.peek()) >= Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                s1.add(item);
            }
        }
        //将s1中剩余的符号依次弹出到S2中
        while(s1.size()>0){
            s2.add(s1.pop());
        }
        return s2;
    }

    //对波兰表达式转成的list进行计算
    public static int calculate(List<String> list){
        Stack<String> stack = new Stack<>();
        for (String item : list) {
            if(item.matches("\\d+")){ //匹配的是数字，直接入栈
                stack.push(item);
            }else{ //匹配的是运算符则弹出两个数进行计算
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if(item.equals("+")){
                    res = num1 + num2;
                }else if(item.equals("-")){
                    res = num1 - num2;
                }else if(item.equals("*")){
                    res = num1 * num2;
                }else if (item.equals("/")){
                    res = num1 / num2;
                }else{
                    throw new RuntimeException("输入的运算符有误！");
                }
                stack.push(res + "");
            }
        }
        //遍历完成，最后留在栈中的数就是表达式结果
        return Integer.parseInt(stack.pop());
    }
}


//判断符号优先级工具类
class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;
	//传入运算符，返回优先级
    public static int getValue(String str){
        int res = 0;
        switch (str){
            case "+":
                res = ADD;
                break;
            case "-":
                res = SUB;
                break;
            case "*":
                res = MUL;
                break;
            case "/":
                res = DIV;
                break;
            default:
                System.out.println("非运算符");
                break;
        }
        return res;
    }
}

```

### 5.递归

#### 5.1递归需要准守的重要规则

```properties
1）执行一个方法时就会创建一个新的受保护的独立空间（棧空间）；
2）方法的局部变量是独立的，不会相互影响；
3）如果方法中使用的是引用数据类型变量（比如数组），就会共享该引用类型的数据；
4）递归必须向递归退出条件逼近，否则就是无限递归，出现StackOverFlowError;
5)当一个方法执行完毕或者遇到return就会返回，准守谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕；
```

#### 5.2递归-迷宫问题

![1583938552298](assets/1583938552298.png)

代码实现：

```java
public class MiGong {
    public static void main(String[] args) {
        //用二维数组创建一个迷宫
        int[][] map = new int[8][7];
        //1代表墙和挡板
        for (int i = 0; i < 7; i++){
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for(int i = 0; i < 8; i++){
            map[i][0] = 1;
            map[i][6] = 1;
        }
        map[3][1] = 1;
        map[3][2] = 1;

        //调用获取路线方法
        setWay(map, 1, 1);
        //打印地图
        for(int i = 0; i < 8; i++){
            for(int j = 0; j < 7; j++){
                System.out.print(map[i][j]+"  ");
            }
            System.out.println();
        }

    }

    /**
     * 说明：0：没走过  1：墙或挡板  2：走过 3：走过但是是死路
     * @param map
     * @param i
     * @param j
     * @return
     */
    public static boolean setWay(int[][] map, int i, int j){
        if(map[6][5] == 2){ //通路已找到，结束方法
            return true;
        }
        if(map[i][j] == 0){ //该点没被走过
            map[i][j] = 2; //走该点
            if(setWay(map, i + 1, j)){ //判断向下走是否是通的
                return true;
            }else if(setWay(map, i, j + 1)){//判断向右走是否是通的
                return true;
            }else if(setWay(map, i - 1, j)){//判断向上走是否是通的
                return true;
            }else if(setWay(map, i, j-1)){//判断向左走是否是通的
                return true;
            }else{ //上下左右都不通，就是死路
                map[i][j] = 3;
                return false;
            }
        }else { //该点是墙或者走过
            return false;
        }
    }
}

```

#### 5.3递归-八皇后问题（回溯算法）

问题介绍：

​	*在8×8的国际象棋上摆放8个皇后，使其不能相互攻击，即：任意两个皇后不处于同一行、同一列或同一斜线上，总共有多少种摆法。（92种）*

问题示意图：

![1584031338334](assets/1584031338334.png)

代码实现：

```java
public class Queue8 {
    int max = 8;    //定义一共8个皇后
    int[] arr = new int[max];   //定义数组，保存皇后放置位置的结果
    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
    }

    //放置第n个皇后
    public void check(int n){
        if(n == max){ //开始放置第九个皇后，结束
            print();
            return;
        }
        for(int i = 0; i < max; i++){
            arr[n] = i;
            if(judge(n)){   //满足条件后并没有终止循环，因此可以把所有的结果输出
                check(n + 1);
            }
        }

    }
    //判断摆放第n个皇后时是否跟前面所有的皇后冲突
    public boolean judge(int n) {
        for(int i = 0; i < n; i++){
            if(arr[i] == arr[n] || Math.abs(n - i) == Math.abs(arr[n] - arr[i])){
                return false;
            }
        }
        //和前面的所有皇后都没冲突就返回true
        return true;
    }

    public void print(){
        for(int i = 0; i < max; i++){
            System.out.print(arr[i]+" ");
        }
        System.out.println();
    }
}

```

### 6.排序算法

#### 6.1排序算法的介绍和分类

1. 定义：排序是将一组数组，以指定的顺序进行排列的过程。

2. 分类：

   1）内部排序：将需要处理的数据加载到内存中进行排序。

   2）外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储（文件等）进行排序。

   3）常见的排序算法分类：

   ![1584193860712](assets/1584193860712.png)

   

#### 6.2算法的时间复杂度

##### 6.2.1度量一个算法执行时间的两种方法

1）事后统计方法：

这种方法可行，但是有两个问题：一是想对算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式要在同一台计算机相同的状态下运行，才能比较出哪个算法速度更快。

2）事前估算方法：

通过分析某个算法的时间复杂度来判断那个算法更优。

##### 6.2.2时间频度

* 基本介绍

  时间频度：一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就越多。一个算法中语句执行次数称为时间频度。即为T（n）

  

* 举例说明-基本案例

  比如计算1-100所有数字之和，我们设计两种算法：

  ![1584194830970](assets/1584194830970.png)

  * 计算时间频次时，随着n加大，可以忽略常数项、低次项、和高次项系数。

##### 6.2.3时间复杂度

```java
1.一般情况下，算法中的基本操作语句的执行次数是问题规模n的某个函数，用T（n）表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记做T(n)=O(f(n)),称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。
2.T(n)不同，但时间复杂度可能相同。如：T(n)=n2+7n+6和T(n)=3n2+2n+2他们的T(n)不同，但时间复杂度相同，都为O(n2)。
3.计算时间复杂度的方法：
	1）省去常数阶T(n)=n2+7n+6 => T(n)=n2+7n
	2)保留n的最高阶项 T(n)=n2+7n => T(n)=n2
	3)去除最高阶项的系数： T(n)=n2 => T(n)=n2
```

##### 6.3.4常见的时间复杂度

```
1.常数阶：O(1)
2.对数阶：O(log2n)
3.线性阶：O(n)
4.线性对数阶：O(nlog2n)
5.平方阶：O(n^2)
6.立方阶：O(n^3)
7.k次方阶：O(n^k)
8.指数阶：O(2^n)
```

常见时间复杂度对应图：

![1584274305968](assets/1584274305968.png)

说明：

1）常见的算法时间复杂度有小到大依次为：O(1)<O(log2^n)<O(n)<O(nlog2^n)<O(n^2)<O(n^3)<O(n^k)<O(2^n)，随着问题规模n逐渐增大，上述时间复杂度不断增大，算法的执行效率越低。

2）从图中可知，我们应尽量避免使用指数阶算法。

##### 6.3.5常用排序算法的平均时间复杂度和最坏时间复杂度

![1584274609488](assets/1584274609488.png)

#### 6.3算法的空间复杂度简介

```java
1.类似于时间复杂度讨论，一个算法的空间复杂度定义为该算法所耗费的存储空间，他也是问题规模n的函数。
2.空间复杂度是对一个算法在运行过程中临时占用储存空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时将占用较多的储存单元，例如快速排序的归并排序算法，基数排序算法就属于这种情况。
3.在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的是程序执行速度。一些缓存产品（redis,memcache）和算法本质就是空间换时间。
```

#### 6.4冒泡排序

```java
1.冒泡排序的基本思想：通过对待排序序列从前向后，依次比较相邻元素的值，若发生逆序则交换，使值较大的元素逐渐从前移向后部，就像水底的气泡一样逐渐向上冒。
2.优化：因为排序过程中，各元素不断接近自己的位置，如果一趟比较下来没有元素进行交换就说明当前序列是有序的。因此要在排序过程中设置一个标志flag判断元素是否进行交换，从而减少不必要的比较。
3.冒泡排序的时间复杂度是O(n^2)
```

代码实现：

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {3, 9, -1, 10, 20};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    //冒泡排序算法
    public static int[] bubbleSort(int[] arr){
        int temp = 0; //临时变量
        boolean flag = false; //优化算法，如果某次循环没有发生位置交换，则证明数组已经有序，就退出循环
        for(int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if(!flag){
                break;
            }else{
                flag = false;
            }
        }
        return arr;
    }
}

```

#### 6.5选择排序

```
1.选择排序思想：
	第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，...，第i次从arr[i-1]~arr[n-1]中选取最小值与arr[i-1]交换，总共通过n-1次得到一个按排序码从小到达排序的有序序列。
```

代码实现：

```java
public class SelectSort {
    public static void main(String[] args) {
        int[] arr = {101, 34, 119, 1, -1, 90, 123};
        selectSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    //选择排序算法
    public static int[] selectSort(int[] arr){
        int min = 0;
        int minIndex = 0;
        for(int i = 0; i < arr.length - 1; i++) {
            //假设当前元素时最小元素
            minIndex = i; 
            min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < min) {
                    min = arr[j];
                    minIndex = j;
                }
            }
            //每一轮循环找到最小的元素和对应的角标，然后交换
            if(minIndex != i) {
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }
        return arr;
    }
}

```

#### 6.6插入排序

##### 6.6.1插入排序算法介绍

```java
1.插入排序属于内部排序，是对于欲排序的元素以插入的方式寻找该元素的位置，以达到排序的目的。
2.插入排序法思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序元素表中排序码进行比较，将它插入有序表中适当位置，使之成为新的有序表。
```

##### 6.6.2代码实现

```java
public class InsertSort {
    public static void main(String[] args) {
        int[] arr = {101, 34, 119, 1, -1, 89};
        insertSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    //插入排序算法
    public static int[] insertSort(int[] arr){
        for(int i = 1; i < arr.length; i++) {
            int insertValue = arr[i];
            int insertIndex = i - 1;
            while (insertIndex >= 0 && insertValue < arr[insertIndex]) {
                //insertVlue与前一位交换
                arr[insertIndex + 1] = arr[insertIndex];
                arr[insertIndex] = insertValue;
                insertIndex--;
            }
        }
        return arr;
    }
}

```

#### 6.7希尔排序

##### 6.7.1插入排序存在的问题

```java
对于数组[2,3,4,5,6,1],当插入最小的数在最后时，要移动整个数组的元素，因而对效率有影响。
```

##### 6.7.2希尔排序法基本思想

```java
	希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减小，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止；
```

##### 6.7.3希尔排序法示意图：

![1584373933971](assets/1584373933971.png)

![1584373952420](assets/1584373952420.png)

##### 6.7.4希尔排序法代码实现

```java
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0};
        shellSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    //希尔排序算法（交换法）
    public static int[] shellSort(int[] arr) {
        int temp = 0;
        for(int gap = arr.length/2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (arr[j] > arr[j + gap]) {
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
        }
        return arr;
    }
    
    //说明：交换法比插入排序效率慢的多，因此使用希尔排序的移位法，效率要比插入排序快很多
    //希尔排序（移位法）
    public static int[] shellSort2(int[] arr) {
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            //从第gap个起，逐个对其所在的组直接进行插入排序
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[j] < arr[j - gap]) {
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    //当退出循环时，就给temp找到了插入位置
                    arr[j] = temp;
                }
            }
        }
        return arr;
    }
}

```

#### 6.8快速排序

##### 6.8.1快速排序介绍

```java
	快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
	注意：测试发现 快速排序比 希尔排序效率要高；
```

##### 6.8.2代码实现：

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {0,1,2,7,8,3,12};
        quickSort(arr, 0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }

    //快速排序算法
    public static int[] quickSort(int[] arr, int left, int right){
        int l = left;
        int r = right;
        int pivot = arr[(left + right) / 2];
        int temp = 0;
        while(l < r){
            //左边向右一直找直到找到比中值大的，退出
            while(arr[l] < pivot){
                l++;
            }
            //右边一直找直到找到比中值小的，退出
            while(arr[r] > pivot){
                r--;
            }
            //l>=r说明pivot两边的值已经全部按照左边的小，右边的大分好组
            if(l >= r){
                break;
            }
            //交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            if(arr[l] == pivot){
                r--;
            }
            if(arr[r] == pivot){
                l++;
            }
        }
        if(l == r){
            l++;
            r--;
        }

        //向左递归
        if(left < r){
            quickSort(arr, left, r);
        }
        //向右递归
        if(right > l){
            quickSort(arr, l, right);
        }
        return arr;
    }
}

```

#### 6.9归并排序

##### 6.9.1归并排序介绍

```java
	归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段将分的阶段得到的答案修补在一起，即分而治之）。
```

归并排序示意图：

![1584635629731](assets/1584635629731.png)

##### 6.9.2代码演示

```java
//说明：该代码有错误，目前没有排查出原因，但是思想是对的
public class MergetSort {
    public static void main(String[] args) {
        int[] arr = {9,5,3,1,2,4,7,6};
        int[] temp = new int[arr.length];
        mergeSort(arr, 0, arr.length-1, temp);
        System.out.println(Arrays.toString(arr));
    }

	//分和并
    public static void mergeSort(int[] arr, int left, int right, int[] temp){
        if(left < right){
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid, temp); //向左递归分解
            mergeSort(arr, mid + 1, right, temp); //向右递归分解
            merge(arr, left, mid, right, temp);
        }
    }

    //合并
    public static void merge(int[] arr, int left, int mid, int right, int[] temp){
        int i = left;
        int j = mid + 1;
        int t = 0;

        //先把左右两边(有序)数据按照规则填充到temp中
        while (i <= mid && j <= right){
            if(arr[i] <= arr[j]){
                temp[t] = arr[i];
                i+=1;
                t+=1;
            }else{
                temp[t] = arr[j];
                j+=1;
                t+=1;
            }
            //把剩余的依次填充进temp
            while(i <= mid){
                temp[t] = arr[i];
                t+=1;
                i+=1;
            }
            while(j <= right){
                temp[t] = arr[j];
                t+=1;
                j+=1;
            }

            //把temp数组元素拷贝到arr,此时对于局部arr来说是有序的
            t = 0; //temp从下标为0开始
            int tempLeft = left;
            while(tempLeft <= right){
                arr[tempLeft] = temp[t];
                t+=1;
                tempLeft+=1;
            }
        }
    }
}

```

#### 6.10基数排序

##### 6.10.1基数排序（桶排序）介绍

```java
1.将所有比较数值统一为同样的数位长度，数位较短的数前面补0.然后从最低位开始，依次进行一次排序，这样从低位到高位排序完成后，数列就变成了有序序列。
2.基数排序法属于稳定性排序，基数排序法是高效的稳定性排序法。
```

##### 6.10.2代码演示

```java
public class RedixSort {
    public static void main(String[] args) {
        int[] arr = {53, 3, 542, 748, 14, 214};
        redixSort(arr);
        System.out.println("排序后的结果：" + Arrays.toString(arr));
    }

    public static void redixSort(int[] arr){
        int[][] bucket = new int[10][arr.length]; //定义十个桶
        int[] buketElementCounts = new int[10]; //每个桶中装入元素个数

        //得到数组里最大数的位数，就是要循环放入桶中和取出的次数
        int max = arr[0];
        for(int i = 1; i < arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
            }
        }
        int maxLength = (max + "").length();

        //j代表循环次数，n：每次循环位数arr[i] / n % 10
        for(int k = 0, n = 1; k < maxLength; k++, n *= 10){
            //将arr元素依次放入桶中
            for(int i = 0; i < arr.length; i++){
                int digitOfElement = arr[i] / n % 10;   //计算出arr[i]的个位数，
                bucket[digitOfElement][buketElementCounts[digitOfElement]] = arr[i];
                buketElementCounts[digitOfElement]++;
            }
            //从桶中取出元素依次放入arr中
            int a = 0;
            for(int i = 0; i<buketElementCounts.length; i++){
                if(buketElementCounts[i] != 0){
                    for(int j = 0; j < buketElementCounts[i]; j++){
                        arr[a++] = bucket[i][j];
                    }
                }
                //每次取完后，将buketElementCounts[i]置零
                buketElementCounts[i] = 0;
            }
        }
    }
}

```

##### 6.10.3基数排序的说明

```java
1.基数排序是对传统桶排序的扩展，速度很快。
2.基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError.
3.基数排序是稳定性排序。（稳定性指：数组中两个值相同的元素，靠前的那个排序完成后还是靠前的）
4.有负数的数组，我们不用基数排序。
```

#### 6.11常用排序算法总结和对比

##### 6.11.1一张排序算法对比图

![1584877651704](assets/1584877651704.png)

相关术语解释：

```
1.稳定：如果a原本在b前面，而a=b，排序后a仍然在b前面；
2.不稳定：如上，排序完后，a可能会在b后面；
3.内排序：所有排序操作都在内存中完成；
4.外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
5.时间复杂度：一个算法执行所消耗的时间；
6.空间复杂度：运行完一个程序所需内存大小；
7.n:数据规模；
8.k:桶的个数；
9.in-place:不占额外内存；
10：out-place:占用额外内存；
```

### 7.查找算法

#### 7.1查找算法介绍

```
在java中，我们常用的查找有四种：
1）顺序（线性）查找；
2）二分查找/折半查找；
3）插值查找；
4）裴波那契查找；
```

#### 7.2线性查找算法

```java
public class SeqSearch {
    public static void main(String[] args) {
        int[] arr = {1, 9, 11, -1, 34, 89};
        int i = seqSearch(arr, -1);
        System.out.println("找到值的下标为：" + i);
    }

    //线性查找算法，找到就返回下标，没有就返回-1
    public static int seqSearch(int[] arr, int value){
        for(int i = 0; i < arr.length; i++){
            if(arr[i] == value){
                return i;
            }
        }
        return -1;
    }
}

```

#### 7.3二分查找

返回一个下标

```java
//注意：使用二分查找的前提是  该数组是有序的
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1, 8 ,10, 89, 123, 586, 896, 1023};
        int i = binarySearch(arr, 0, arr.length, 86);
        System.out.println("找到下标为：" + i);
    }


    /**
     *  //二分查找算法，查找到返回下标，找不到返回-1
     * @param arr 要查找到额数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param value 要查找的值
     * @return 找到的值的下标，没有找到返回-1
     */
    public static int binarySearch(int[] arr, int left, int right, int value){
        if(left > right){//查找完后仍然没有找到
            return -1;
        }
        //数组中间角标
        int mid = (left + right) / 2;
        //中间值
        int midValue = arr[mid];
        if(value < midValue){ //向左递归
            mid = binarySearch(arr, left, mid - 1, value);
        }else if(value > midValue){//向右递归
            mid = binarySearch(arr, mid + 1, right, value);
        }
        return mid;
    }
}

```

返回找到的所有的下标

```java
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1, 8 ,10, 89, 123, 586, 586, 586, 896, 1023};
        List<Integer> list = binarySearchAll(arr, 0, arr.length, 586);
        System.out.println("找到下标为：" + list);
    }

    /**
     * 问题：如果查找的值在数组中有多个，返回多个下标值
     * 解决：找到mid值之后不要立马返回，由于是有序数组，可以向前和向后遍历找到相同的值角标放入集合中返回
     * @param arr
     * @param left
     * @param right
     * @param value
     * @return 找到的值的下标集合，没有找到返回空集合
     */
    public static List<Integer> binarySearchAll(int[] arr, int left, int right, int value){
        if(left > right){//查找完后仍然没有找到
            return new ArrayList<Integer>();
        }
        //数组中间角标
        int mid = (left + right) / 2;
        //中间值
        int midValue = arr[mid];
        if(value < midValue){ //向左递归
            mid = binarySearch(arr, left, mid - 1, value);
        }else if(value > midValue){//向右递归
            mid = binarySearch(arr, mid + 1, right, value);
        }

        //向前和向后遍历看有没有相同的值
        ArrayList<Integer> indexs = new ArrayList<>();
        //向左遍历
        int temp = mid - 1;
        while (true){
            if(temp < 0 || arr[temp] != value){
                break;
            }
            indexs.add(temp);
            temp--;
        }
        indexs.add(mid);
        //向右遍历
        temp = mid + 1;
        while(true){
            if(temp > arr.length - 1 || arr[temp] != value){
                break;
            }
            indexs.add(temp);
            temp++;
        }
        return indexs;
    }
}

```

#### 7.4插值查找

##### 7.4.1插值查找算法介绍

```java
1.插值查找原理：插值查找类似于二分查找，不同的是插值查找每次从自适应mid处开始查找；
2.将折半查找中的求mid索引的公式改变如下：
	折半查找mid = (left + right) / 2
    插值查找mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left])
3.这种自适应mid公式能很快定位到要找的值value，其余算法和二分查找一样；
```

##### 7.4.2插值查找算法注意事项

```
1.对于数据量较大，关键字分布比较均匀的查找来说，采用插值查找，速度较快；
2.关键字分布不均匀的情况下，该方法不一定比折半查找要好；
```

##### 7.4.3代码实现

```java
public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr = {1, 8 ,10, 89, 123, 586, 586, 586, 896, 1023};
        int i = insertValueSearch(arr, 0, arr.length - 1, 1);
        System.out.println("找到角标为" + i);
    }

    public static int insertValueSearch(int[] arr, int left, int right, int value){
        //注意：value < arr[0] || value > arr[arr.length - 1] 必须加上，否则可能引起角标越界
        if(left > right || value < arr[0] || value > arr[arr.length - 1]){
            return -1;
        }
        //插值查找自适应中间角标公式
        int mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]);
        int midValue = arr[mid];
        if(value < midValue){
            mid = insertValueSearch(arr, left, mid - 1, value);
        }else if(value > midValue){
            mid = insertValueSearch(arr, mid + 1, right, value);
        }
        return mid;
    }
}

```

#### 7.5斐波那契（黄金分割法）查找算法

##### 7.5.1斐波那契查找算法原理

```java 
	斐波那契查找原理与前两种类似，仅仅改变了中间节点（mid）的位置，mid不再是中间值或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1(F代表斐波那契数列)；
	
	对F（k-1）-1的理解：
	1）由斐波那契数列F[k] = F[k-1] + F[k-2]的性质，可以得到(F[k] - 1) = (F[k-1] - 1) + (F[k-2] - 1)+1。该式说明只要顺序表的长度为F[k]-1,则可以将该表分为长度为F[k-1]-1和F[k-2]-1的两段，从而中间位置为mid=low + F[k-1]-1
    2)类似的每一子段也可以用相同的方式分割；
    3）但顺序表长度n不一定刚好等于F[k]-1,所以需要将原来顺序长度n增加至F[k]-1,这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都都赋为n位置的值即可。
    	while(n>fib(k)-1)
    		k++;

//具体算法代码详见学习资料
```

### 8.哈希表

#### 8.1哈希表的基本介绍

```java
	散列表（Hash table,也叫哈希表），是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数据叫做散列表。
```

![1584978521157](assets/1584978521157.png)

#### 8.2实际应用（谷歌上机题）

```
	有一个公司，当有新员工来报道时，要求将该员工的信息加入（id,name...）,当输入该员工的id时，要求查找到该员工的所有信息。
	要求：
	1）不使用数据库，速度越快越好=>哈希表（散列）
	2）添加时，保证按照id从低到高插入；
	3）使用链表来实现哈希表，该链表不带头[即链表的第一个节点就存放雇员信息]
```

代码实现：

```java
public class HashTableDemo {
    public static void main(String[] args) {
        HashTable hashTable = new HashTable(7);
        Scanner scanner = new Scanner(System.in);
        String key = "";
        while(true){
            System.out.println("add:添加");
            System.out.println("list:显示");
            System.out.println("find:查找");
            System.out.println("exit:退出");
            key = scanner.next();
            switch (key){
                case "add":
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入name");
                    String name = scanner.next();
                    Employer employer = new Employer(id, name);
                    hashTable.add(employer);
                    break;
                case "list":
                    hashTable.list();
                    break;
                case "find":
                    System.out.println("请输入id");
                    int i = scanner.nextInt();
                    hashTable.find(i);
                    break;
                case "exit":
                    System.out.println("程序已退出");
                    scanner.close();
                    System.exit(0);
                default:
                    break;
            }
        }
    }
}

/**
 * 创建hashtable管理多条链表
 */
class HashTable{
    private int size;
    private EmployerLinkedList[] employerLinkedListArray;

    /**
     * 构造函数
     * @param size
     */
    public HashTable(int size){
        this.size = size;
        employerLinkedListArray = new EmployerLinkedList[size];
        //注意：此时只是初始化了一个数组，数组里面每个链表也要初始化
        for(int i = 0; i < size; i++){
            employerLinkedListArray[i] = new EmployerLinkedList();
        }
    }

    /**
     * 添加雇员
     * @param employer
     */
    public void add(Employer employer){
        int i = hashFun(employer.getId());
        employerLinkedListArray[i].add(employer);
    }

    /**
     * 遍历
     */
    public void list(){
        for(int i = 0; i < size; i++){
            employerLinkedListArray[i].list(i);
        }
    }

    /**
     * 根据id找到雇员
     * @param id
     * @return
     */
    public void find(int id){
        int i = hashFun(id); //在数组下标为i的链表中找
        Employer emp = employerLinkedListArray[i].findEmp(id);
        if(emp != null){
            System.out.printf("在第%d条链表中找到雇员 id=%d\n", (i+1), id);
        }else{
            System.out.println("在哈希表中没有找到该雇员~");
        }
    }

    /**
     * 编写一个散列函数，根据id算出放到哪个链表
     * @param id
     * @return
     */
    public int hashFun(int id){
        return id % size;
    }
}

/**
 * 链表
 */
class EmployerLinkedList{
    private Employer head; //头节点

    /**
     * 添加节点
     * @param employer
     */
    public void add(Employer employer){
        if(head == null){ //添加第一个节点
            head = employer;
        }else{ //不是第一个节点,遍历添加到链表最后
            Employer temp = head;
            while(true){
                if(temp.getNext() == null){
                    temp.setNext(employer);
                    break;
                }
                temp = temp.getNext();
            }
        }
    }

    /**
     * 遍历链表
     * @param no
     */
    public void list(int no){
        if(head == null){
            System.out.println("第" + (no + 1) + "条链表是空的~");
            return;
        }
        System.out.print("第" + (no + 1) + "条链表的信息是");
        Employer temp = head; // 辅助指针
        while (true){
            if(temp != null){
                System.out.print("  ==>id=" + temp.getId() + ",name=" + temp.getName());
            }else {
                break;
            }
            temp = temp.getNext();
        }
        System.out.println();
    }

    /**
     * 查找雇员,如果查找到返回employer，没有查找到返回null
     * @param id
     * @return
     */
    public Employer findEmp(int id){
        //判断链表是否为空
        if(head == null){
            System.out.println("链表为空~");
            return null;
        }
        Employer temp = head;
        while (true){
            if(temp == null){ //遍历到最后没有找到
                break;
            }
            if(temp.getId() == id){ //找到了
                break;
            }
            temp = temp.getNext();
        }
        return temp;
    }
}

/**
 * 雇员类
 */
class Employer{
    private int id;
    private String name;
    private Employer next;
    public Employer(int id, String name){
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employer getNext() {
        return next;
    }

    public void setNext(Employer next) {
        this.next = next;
    }
}


```

### 9.树结构的基础部分

#### 9.1二叉树

##### 9.1.1为什么需要数这种数据结构

```java
1.数组储存方式的分析：
	优点：通过下标方式访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度。
	缺点：如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率较低。
	补充：ArrayList底层使用的就是数组，构造方法初始化一个空数组，当添加元素时首先判断是否需要扩容，如果需要，就会扩充1.5倍。
2.链式储存方式分析：
	优点：在一定程度上对数组储存方式有优化（比如：插入一个数值节点，只需要将插入节点，连接到链表中即可，删除效率也很好）。
	缺点：在进行检索时效率仍然较低，比如 检索某个值需要从头节点开始遍历。
3.树储存方式分析：
	能提高数据储存，读取的效率，比如利用二叉排序树（Binary Sort Tree）,既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。   如下图所示：
```

![1585068028281](assets/1585068028281.png)

##### 9.1.2树示意图

![1585068764493](assets/1585068764493.png)

```java
树的常用术语（结合示意图理解）：
1.节点
2.根节点
3.父节点
4.子节点
5.叶子节点（没有子节点的节点）
6.节点的权（节点值）
7.路径（从root节点找到该节点的路线）
8.层
9.子树
10.数的高度（最大层数）
11.森林：多棵子树构成森林
```

##### 9.1.3二叉树的概念

1）树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。

2）二叉树的子节点分为左节点和右节点

3）示意图：

![1585069093071](assets/1585069093071.png)

4）如果该二叉树的所有叶子节点都在最后一层，并且节点总数=2^n-1,n为层数，则我们称为满二叉树；

![1585069169361](assets/1585069169361.png)

5）如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树

![1585069264524](assets/1585069264524.png)

##### 9.1.4二叉树遍历说明

```java
1.前序遍历：先输出父节点，再遍历左子树和右子树
2.中序遍历：先遍历左子树，再输出父节点，再遍历右子树；
3.后序遍历：先遍历左子树，再遍历右子树，再输出父节点；
4.小结：看输出父节点的顺序，就确定是前序、中序还是后序；
```

##### 9.1.5二叉树遍历实例

```java
//说明：类似于链表节点，，但是遍历的方法是在每个节点中写的，前序中序后序是针对于父节点的输出顺序

public class BinaryTreeDemo {
    public static void main(String[] args) {
        //创建需要的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
        //说明：手动创建二叉树，后面学习如何用递归创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        //创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree(root);

        //测试
        System.out.println("前序遍历");
        binaryTree.preOrder();  //1,2,3,5,4

        //中序遍历
        System.out.println("中序遍历");
        binaryTree.infixOrder(); //2,1,5,3,4

        //后序遍历
        System.out.println("后序遍历");
        binaryTree.postOrder(); //25431
    }
}

class BinaryTree{
    private HeroNode root;
    public BinaryTree(HeroNode root){
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if(root != null){
            root.preOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder(){
        if(root != null){
            root.infixOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //后序遍历
    public void postOrder(){
        if(root != null){
            root.postOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }
}

/**
 * 节点类
 */
class HeroNode{
    private int no;
    private String name;
    private HeroNode left; //默认null
    private HeroNode right; //默认null
    public HeroNode(int no, String name){
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    //编写前序遍历的方法
    public void preOrder(){
        System.out.println(this); //先输出父节点
        //递归向左子树前序遍历
        if (this.left != null){
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if(this.right != null){
            this.right.preOrder();
        }
    }


    //中序遍历
    public void infixOrder(){
        //递归向左子树中序遍历
        if(this.left != null){
            this.left.infixOrder();
        }
        //输出父节点
        System.out.println(this);
        //递归向右子树中序遍历
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    //后序遍历
    public void postOrder(){
        //递归向左子树后序遍历
        if(this.left != null){
            this.left.postOrder();
        }
        //递归向右子树后序遍历
        if(this.right != null){
            this.right.postOrder();
        }
        //输出父节点
        System.out.println(this);
    }
}

```

##### 9.1.6二叉树查找指定节点

![1585239956549](assets/1585239956549.png)

代码实现：

```java
package com.fy.tree;

/**
 * @program: algorithm->BinaryTreeDemo
 * @description: 二叉树遍历（前序、中序、后序）
 * @author: fangyan
 * @create: 2020-03-26 22:32
 **/
public class BinaryTreeDemo {
    public static void main(String[] args) {
        //创建需要的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
        //说明：手动创建二叉树，后面学习如何用递归创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        //创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree(root);
        //前序查找
        System.out.println("前序查找~");
        HeroNode resNode = binaryTree.preOrderSearch(2);
        if(resNode != null){
            System.out.printf("找到了信息为no=%d,name=%s \n", resNode.getNo(), resNode.getName());
        }else{
            System.out.println("没有找到节点为4的");
        }
        //中序、后序 略。。。
    }
}

class BinaryTree{
    private HeroNode root;
    public BinaryTree(HeroNode root){
        this.root = root;
    }

    //前序查找
    public HeroNode preOrderSearch(int no){
        if(root != null){
            return root.preOrderSearch(no);
        }else{
            return null;
        }
    }

    //中序查找
    public HeroNode infixOrderSearch(int no){
        if(root != null){
            return root.infixOrderSearch(no);
        }else{
            return null;
        }
    }

    //后序查找
    public HeroNode postOrderSearch(int no){
        if(root != null){
            return root.postOrderSearch(no);
        }else{
            return null;
        }
    }
}

/**
 * 节点类
 */
class HeroNode{
    private int no;
    private String name;
    private HeroNode left; //默认null
    private HeroNode right; //默认null
    public HeroNode(int no, String name){
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    /**
     * 前序、中序、后序  查找
     * @param no
     * @return
     */
    //前序查找
    public HeroNode preOrderSearch(int no){
        //比较当前节点是不是
        if(this.no == no){
            return this;
        }
        //判断当前节点的左子节点是否为空，不为空就遍历查找
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null) { //说明在左子树上找到了，直接返回
            return resNode;
        }
        //判断当前节点的右子节点是否为空，不为空就遍历查找
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    //中序查找
    public HeroNode infixOrderSearch(int no){
        //左子节点查找
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }
        if(resNode != null){ //左子节点找到，直接返回
            return resNode;
        }
        //判断当前节点是否满足
        if (this.no == no){
            return this;
        }
        //右子节点查找
        if(this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode; //最后的右子树查找，找到找不到都要返回
    }

    //后序查找
    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        //判断左子树
        if(this.left != null){
            resNode = this.left.postOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        //右子树查找
        if(this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if(resNode != null){
            return  resNode;
        }
        //判断当前节点是否满足
        if(this.no == no){
            return this;
        }
        return resNode;
    }
}

```

